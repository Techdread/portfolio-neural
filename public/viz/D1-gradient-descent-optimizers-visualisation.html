<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent Explorer</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Import Map for Modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: white; }
        /* Custom scrollbar for sidebar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- ICONS (Inline SVGs to replace lucide-react) ---
        const IconWrapper = ({ children, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const SettingsIcon = ({ className }) => (
            <IconWrapper className={className}>
                <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
                <circle cx="12" cy="12" r="3" />
            </IconWrapper>
        );
        const PlayIcon = ({ className }) => (
            <IconWrapper className={className}>
                <polygon points="5 3 19 12 5 21 5 3" fill="currentColor" />
            </IconWrapper>
        );
        const PauseIcon = ({ className }) => (
            <IconWrapper className={className}>
                <rect x="6" y="4" width="4" height="16" fill="currentColor" />
                <rect x="14" y="4" width="4" height="16" fill="currentColor" />
            </IconWrapper>
        );
        const RotateCcwIcon = ({ className }) => (
            <IconWrapper className={className}>
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                <path d="M3 3v5h5" />
            </IconWrapper>
        );
        const FastForwardIcon = ({ className }) => (
            <IconWrapper className={className}>
                <polygon points="13 19 22 12 13 5 13 19" />
                <polygon points="2 19 11 12 2 5 2 19" />
            </IconWrapper>
        );
        const InfoIcon = ({ className }) => (
            <IconWrapper className={className}>
                <circle cx="12" cy="12" r="10" />
                <path d="M12 16v-4" />
                <path d="M12 8h.01" />
            </IconWrapper>
        );
        const MousePointer2Icon = ({ className }) => (
            <IconWrapper className={className}>
                <path d="m12 12 3-3 5 5-7.5 7.5-6-6 7.5-7.5 5 5" />
            </IconWrapper>
        );


        // --- CONSTANTS & HELPERS ---
        const INITIAL_POS = { x: 3, y: 3 };
        const add = (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y });
        const sub = (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y });
        const mul = (v, s) => ({ x: v.x * s, y: v.y * s });
        const div = (v, s) => ({ x: v.x / s, y: v.y / s });
        const mag = (v) => Math.sqrt(v.x * v.x + v.y * v.y);
        const EPSILON = 0.001;

        const surfaces = {
            bowl: {
                name: "Simple Bowl",
                fn: (x, y) => 0.15 * (x * x + y * y),
                range: 10,
                desc: "A standard convex problem. All optimizers should find the center easily."
            },
            ravine: {
                name: "Ravine",
                fn: (x, y) => 0.05 * x * x + 1.5 * y * y,
                range: 10,
                desc: "Steep in one dimension, flat in the other. Watch Vanilla SGD oscillate!"
            },
            minima: {
                name: "Local Minima Field",
                fn: (x, y) => {
                    const r = Math.sqrt(x*x + y*y);
                    return 0.5 * r * r - 2 * Math.cos(x) - 2 * Math.cos(y) + 4;
                },
                range: 10,
                desc: "Bumpy terrain. Momentum is needed to escape the small holes."
            },
            saddle: {
                name: "Saddle Point",
                fn: (x, y) => 0.1 * (x * x - y * y),
                range: 10,
                desc: "Curves up in one direction, down in another. Gradients can vanish near the center."
            }
        };

        const getGradient = (fn, x, y) => {
            const f = fn(x, y);
            const fx = fn(x + EPSILON, y);
            const fy = fn(x, y + EPSILON);
            return {
                x: (fx - f) / EPSILON,
                y: (fy - f) / EPSILON
            };
        };

        // --- MAIN COMPONENT ---
        const GradientDescentVis = () => {
            // Refs
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const meshRef = useRef(null);
            const markersRef = useRef({});
            const trailsRef = useRef({});

            // State
            const [isPlaying, setIsPlaying] = useState(false);
            const [iteration, setIteration] = useState(0);
            const [surfaceKey, setSurfaceKey] = useState('bowl');
            const [simSpeed, setSimSpeed] = useState(1);
            const [learningRate, setLearningRate] = useState(0.05);
            
            // Hyperparameters
            const [momentumBeta, setMomentumBeta] = useState(0.9);
            const [rmsDecay, setRmsDecay] = useState(0.9);
            const [adamBeta1, setAdamBeta1] = useState(0.9);
            const [adamBeta2, setAdamBeta2] = useState(0.999);

            // Optimizers
            const [optimizers, setOptimizers] = useState([
                { name: 'Vanilla SGD', color: '#ef4444', pos: INITIAL_POS, velocity: {x:0, y:0}, cache: {x:0, y:0}, iter: 0, path: [INITIAL_POS], converged: false, active: true },
                { name: 'Momentum', color: '#3b82f6', pos: INITIAL_POS, velocity: {x:0, y:0}, cache: {x:0, y:0}, iter: 0, path: [INITIAL_POS], converged: false, active: true },
                { name: 'RMSprop', color: '#22c55e', pos: INITIAL_POS, velocity: {x:0, y:0}, cache: {x:0, y:0}, iter: 0, path: [INITIAL_POS], converged: false, active: true },
                { name: 'Adam', color: '#f97316', pos: INITIAL_POS, velocity: {x:0, y:0}, cache: {x:0, y:0}, iter: 0, path: [INITIAL_POS], converged: false, active: true },
            ]);

            // --- Three.js Setup ---
            useEffect(() => {
                if (!mountRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0f172a);
                scene.fog = new THREE.Fog(0x0f172a, 10, 50);

                const camera = new THREE.PerspectiveCamera(45, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
                camera.position.set(10, 10, 10);

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const gridHelper = new THREE.GridHelper(20, 20, 0x334155, 0x1e293b);
                scene.add(gridHelper);

                const geometry = new THREE.PlaneGeometry(14, 14, 64, 64);
                geometry.rotateX(-Math.PI / 2);
                
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    roughness: 0.6,
                    metalness: 0.1,
                    flatShading: false,
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.receiveShadow = true;
                mesh.castShadow = true;
                scene.add(mesh);

                sceneRef.current = scene;
                cameraRef.current = camera;
                rendererRef.current = renderer;
                controlsRef.current = controls;
                meshRef.current = mesh;

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                const onMouseClick = (event) => {
                    if (!meshRef.current) return;
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(meshRef.current);

                    if (intersects.length > 0) {
                        const point = intersects[0].point;
                        // Use a timeout to avoid conflicts with state updates during render
                        setTimeout(() => resetOptimizers(point.x, point.z), 0);
                    }
                };

                renderer.domElement.addEventListener('dblclick', onMouseClick);

                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    if (!mountRef.current || !cameraRef.current || !rendererRef.current) return;
                    cameraRef.current.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
                    cameraRef.current.updateProjectionMatrix();
                    rendererRef.current.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    renderer.domElement.removeEventListener('dblclick', onMouseClick);
                    mountRef.current?.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, []);

            // --- Surface Update ---
            useEffect(() => {
                if (!meshRef.current) return;
                
                const geom = meshRef.current.geometry;
                const posAttribute = geom.attributes.position;
                const colors = [];
                const count = posAttribute.count;
                const surfaceFn = surfaces[surfaceKey].fn;

                let minH = Infinity;
                let maxH = -Infinity;

                for (let i = 0; i < count; i++) {
                    const x = posAttribute.getX(i);
                    const z = posAttribute.getZ(i);
                    const y = surfaceFn(x, z);
                    posAttribute.setY(i, y);
                    if (y < minH) minH = y;
                    if (y > maxH) maxH = y;
                }

                const colorMin = new THREE.Color(0x3b82f6);
                const colorMax = new THREE.Color(0xf43f5e);

                for (let i = 0; i < count; i++) {
                    const y = posAttribute.getY(i);
                    const alpha = (y - minH) / (maxH - minH || 1);
                    const color = colorMin.clone().lerp(colorMax, alpha);
                    colors.push(color.r, color.g, color.b);
                }

                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geom.computeVertexNormals();
                posAttribute.needsUpdate = true;
                
                resetOptimizers(INITIAL_POS.x, INITIAL_POS.y);
            }, [surfaceKey]);

            // --- Visuals Update ---
            useEffect(() => {
                if (!sceneRef.current) return;
                const scene = sceneRef.current;
                const surfaceFn = surfaces[surfaceKey].fn;

                optimizers.forEach(opt => {
                    // Marker
                    if (!markersRef.current[opt.name]) {
                        const sphereGeom = new THREE.SphereGeometry(0.15, 16, 16);
                        const sphereMat = new THREE.MeshBasicMaterial({ color: opt.color });
                        const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                        scene.add(sphere);
                        markersRef.current[opt.name] = sphere;
                    }
                    
                    const marker = markersRef.current[opt.name];
                    const yHeight = surfaceFn(opt.pos.x, opt.pos.y);
                    marker.position.set(opt.pos.x, yHeight, opt.pos.y);
                    marker.visible = opt.active;

                    // Trail
                    if (!trailsRef.current[opt.name]) {
                        const geom = new THREE.BufferGeometry();
                        const maxPoints = 1000; 
                        const positions = new Float32Array(maxPoints * 3);
                        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        geom.setDrawRange(0, 0);

                        const mat = new THREE.LineBasicMaterial({ color: opt.color, linewidth: 2 });
                        const line = new THREE.Line(geom, mat);
                        line.position.y = 0.05; 
                        scene.add(line);
                        trailsRef.current[opt.name] = line;
                    }

                    const trail = trailsRef.current[opt.name];
                    trail.visible = opt.active;
                    
                    if (opt.active) {
                        const positions = trail.geometry.attributes.position.array;
                        let idx = 0;
                        opt.path.forEach((p) => {
                            if (idx >= 3000) return;
                            const ph = surfaceFn(p.x, p.y);
                            positions[idx++] = p.x;
                            positions[idx++] = ph;
                            positions[idx++] = p.y;
                        });
                        
                        trail.geometry.setDrawRange(0, opt.path.length);
                        trail.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }, [optimizers, surfaceKey]);

            // --- Logic ---
            const resetOptimizers = (x, y) => {
                setIsPlaying(false);
                setIteration(0);
                const startPos = { x, y };
                
                setOptimizers(prev => prev.map(opt => ({
                    ...opt,
                    pos: startPos,
                    velocity: { x: 0, y: 0 },
                    cache: { x: 0, y: 0 },
                    iter: 0,
                    path: [startPos],
                    converged: false
                })));
            };

            const stepOptimizers = useCallback(() => {
                setOptimizers(prevOpts => {
                    return prevOpts.map(opt => {
                        if (!opt.active || opt.converged) return opt;

                        const { x, y } = opt.pos;
                        const grad = getGradient(surfaces[surfaceKey].fn, x, y);
                        const gradMag = mag(grad);

                        if (gradMag < 0.001) {
                            return { ...opt, converged: true };
                        }

                        let newPos = { ...opt.pos };
                        let newVel = { ...opt.velocity };
                        let newCache = { ...opt.cache };
                        let newIter = opt.iter + 1;

                        if (opt.name === 'Vanilla SGD') {
                            newPos = sub(opt.pos, mul(grad, learningRate));
                        } 
                        else if (opt.name === 'Momentum') {
                            newVel = add(mul(opt.velocity, momentumBeta), grad);
                            newPos = sub(opt.pos, mul(newVel, learningRate));
                        }
                        else if (opt.name === 'RMSprop') {
                            newCache = {
                                x: rmsDecay * opt.cache.x + (1 - rmsDecay) * grad.x * grad.x,
                                y: rmsDecay * opt.cache.y + (1 - rmsDecay) * grad.y * grad.y
                            };
                            const stepX = (learningRate / (Math.sqrt(newCache.x) + 1e-8)) * grad.x;
                            const stepY = (learningRate / (Math.sqrt(newCache.y) + 1e-8)) * grad.y;
                            newPos = { x: opt.pos.x - stepX, y: opt.pos.y - stepY };
                        }
                        else if (opt.name === 'Adam') {
                            const m = {
                                x: adamBeta1 * opt.velocity.x + (1 - adamBeta1) * grad.x,
                                y: adamBeta1 * opt.velocity.y + (1 - adamBeta1) * grad.y
                            };
                            const v = {
                                x: adamBeta2 * opt.cache.x + (1 - adamBeta2) * grad.x * grad.x,
                                y: adamBeta2 * opt.cache.y + (1 - adamBeta2) * grad.y * grad.y
                            };
                            const mHat = div(m, 1 - Math.pow(adamBeta1, newIter));
                            const vHat = div(v, 1 - Math.pow(adamBeta2, newIter));

                            const stepX = (learningRate / (Math.sqrt(vHat.x) + 1e-8)) * mHat.x;
                            const stepY = (learningRate / (Math.sqrt(vHat.y) + 1e-8)) * mHat.y;

                            newPos = { x: opt.pos.x - stepX, y: opt.pos.y - stepY };
                            newVel = m;
                            newCache = v;
                        }

                        const LIMIT = 7;
                        if (Math.abs(newPos.x) > LIMIT || Math.abs(newPos.y) > LIMIT) {
                            return { ...opt, converged: true };
                        }

                        return {
                            ...opt,
                            pos: newPos,
                            velocity: newVel,
                            cache: newCache,
                            iter: newIter,
                            path: [...opt.path, newPos]
                        };
                    });
                });
                setIteration(i => i + 1);
            }, [surfaceKey, learningRate, momentumBeta, rmsDecay, adamBeta1, adamBeta2]);

            useEffect(() => {
                let interval;
                if (isPlaying) {
                    const delay = Math.max(10, 100 / simSpeed);
                    interval = setInterval(stepOptimizers, delay);
                }
                return () => clearInterval(interval);
            }, [isPlaying, simSpeed, stepOptimizers]);

            const toggleOptimizer = (idx) => {
                setOptimizers(prev => {
                    const next = [...prev];
                    next[idx].active = !next[idx].active;
                    return next;
                });
            };

            return (
                <div className="flex flex-col h-screen w-full bg-slate-900 text-slate-100 font-sans overflow-hidden">
                    {/* Header */}
                    <div className="flex-none p-4 bg-slate-800 border-b border-slate-700 flex justify-between items-center z-10 shadow-md">
                        <div>
                            <h1 className="text-xl font-bold flex items-center gap-2">
                                <SettingsIcon className="w-6 h-6 text-blue-400" />
                                Gradient Descent Explorer
                            </h1>
                            <p className="text-xs text-slate-400 mt-1">
                                Double click anywhere on the 3D surface to set a new starting point.
                            </p>
                        </div>
                        <div className="flex items-center gap-4">
                            <div className="flex flex-col">
                                <label className="text-[10px] uppercase tracking-wider text-slate-400 font-semibold mb-1">Terrain</label>
                                <select 
                                    value={surfaceKey} 
                                    onChange={(e) => setSurfaceKey(e.target.value)}
                                    className="bg-slate-700 text-sm border border-slate-600 rounded px-2 py-1 outline-none focus:border-blue-500"
                                >
                                    {Object.entries(surfaces).map(([key, val]) => (
                                        <option key={key} value={key}>{val.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 flex relative">
                        {/* Canvas */}
                        <div ref={mountRef} className="flex-1 relative cursor-crosshair">
                            <div className="absolute top-4 left-4 bg-slate-800/90 backdrop-blur p-3 rounded-lg border border-slate-700 shadow-xl pointer-events-none select-none">
                                <div className="text-xs text-slate-400 uppercase font-bold mb-2">Live Stats</div>
                                <div className="text-2xl font-mono text-white mb-2">Step: {iteration}</div>
                                <div className="space-y-1">
                                    {optimizers.map(opt => opt.active && (
                                        <div key={opt.name} className="flex items-center gap-2 text-xs">
                                            <div className="w-2 h-2 rounded-full" style={{background: opt.color}}></div>
                                            <span className="w-20 font-semibold">{opt.name}:</span> 
                                            <span className="font-mono opacity-80">
                                                Loss: {surfaces[surfaceKey].fn(opt.pos.x, opt.pos.y).toFixed(4)}
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>

                        {/* Sidebar */}
                        <div className="w-80 bg-slate-800 border-l border-slate-700 flex flex-col overflow-y-auto">
                            
                            {/* Controls moved to top */}
                            <div className="p-4 border-b border-slate-700 bg-slate-800/50">
                                <div className="flex items-center justify-between mb-2">
                                    <span className="text-xs text-slate-400 font-bold">SIMULATION SPEED</span>
                                    <span className="text-xs font-mono">{simSpeed}x</span>
                                </div>
                                <input 
                                    type="range" min="0.1" max="5" step="0.1" 
                                    value={simSpeed} onChange={(e) => setSimSpeed(parseFloat(e.target.value))}
                                    className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer mb-6"
                                />

                                <div className="flex justify-center gap-4">
                                    <button 
                                        onClick={() => resetOptimizers(INITIAL_POS.x, INITIAL_POS.y)}
                                        className="p-3 rounded-full bg-slate-700 hover:bg-slate-600 text-white transition-all hover:scale-105 active:scale-95"
                                        title="Reset"
                                    >
                                        <RotateCcwIcon className="w-5 h-5" />
                                    </button>
                                    
                                    <button 
                                        onClick={() => setIsPlaying(!isPlaying)}
                                        className={`p-4 rounded-full text-white shadow-lg transition-all hover:scale-105 active:scale-95 ${isPlaying ? 'bg-amber-500 hover:bg-amber-400' : 'bg-green-600 hover:bg-green-500'}`}
                                    >
                                        {isPlaying ? <PauseIcon className="w-6 h-6 fill-current" /> : <PlayIcon className="w-6 h-6 fill-current ml-1" />}
                                    </button>

                                    <button 
                                        onClick={stepOptimizers}
                                        disabled={isPlaying}
                                        className="p-3 rounded-full bg-slate-700 hover:bg-slate-600 text-white transition-all hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed"
                                        title="Step Forward"
                                    >
                                        <FastForwardIcon className="w-5 h-5" />
                                    </button>
                                </div>
                            </div>

                            <div className="p-4 border-b border-slate-700">
                                <h3 className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-3">Optimizers</h3>
                                <div className="space-y-2">
                                    {optimizers.map((opt, idx) => (
                                        <div 
                                            key={opt.name} 
                                            className={`flex items-center justify-between p-2 rounded cursor-pointer transition-colors ${opt.active ? 'bg-slate-700/50' : 'opacity-50 hover:bg-slate-700/30'}`}
                                            onClick={() => toggleOptimizer(idx)}
                                        >
                                            <div className="flex items-center gap-3">
                                                <div className={`w-3 h-3 rounded-sm shadow-sm`} style={{backgroundColor: opt.color}}></div>
                                                <span className="text-sm font-medium">{opt.name}</span>
                                            </div>
                                            <div className="text-[10px] font-mono text-slate-400">
                                                {opt.converged ? 'DONE' : 'RUNNING'}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <div className="p-4 border-b border-slate-700 space-y-4">
                                <h3 className="text-xs font-bold text-slate-400 uppercase tracking-wider">Hyperparameters</h3>
                                
                                <div>
                                    <div className="flex justify-between text-xs mb-1">
                                        <span>Learning Rate (α)</span>
                                        <span className="font-mono text-blue-300">{learningRate.toFixed(3)}</span>
                                    </div>
                                    <input 
                                        type="range" min="0.001" max="0.5" step="0.001" 
                                        value={learningRate} onChange={(e) => setLearningRate(parseFloat(e.target.value))}
                                        className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>

                                <div>
                                    <div className="flex justify-between text-xs mb-1">
                                        <span>Momentum (β)</span>
                                        <span className="font-mono text-blue-300">{momentumBeta.toFixed(2)}</span>
                                    </div>
                                    <input 
                                        type="range" min="0" max="0.99" step="0.01" 
                                        value={momentumBeta} onChange={(e) => setMomentumBeta(parseFloat(e.target.value))}
                                        className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>

                                <div className="pt-2 border-t border-slate-700/50">
                                    <div className="flex justify-between text-xs mb-1">
                                        <span>Adam β1</span>
                                        <span className="font-mono text-orange-300">{adamBeta1.toFixed(2)}</span>
                                    </div>
                                    <input 
                                        type="range" min="0.8" max="0.999" step="0.001" 
                                        value={adamBeta1} onChange={(e) => setAdamBeta1(parseFloat(e.target.value))}
                                        className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer"
                                    />
                                    <div className="flex justify-between text-xs mb-1 mt-2">
                                        <span>Adam β2</span>
                                        <span className="font-mono text-orange-300">{adamBeta2.toFixed(3)}</span>
                                    </div>
                                    <input 
                                        type="range" min="0.8" max="0.999" step="0.001" 
                                        value={adamBeta2} onChange={(e) => setAdamBeta2(parseFloat(e.target.value))}
                                        className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>
                            </div>

                            <div className="p-4 flex-1">
                                <div className="bg-blue-900/20 border border-blue-800/50 rounded p-3">
                                    <div className="flex items-start gap-2">
                                        <InfoIcon className="w-4 h-4 text-blue-400 shrink-0 mt-0.5" />
                                        <p className="text-xs text-blue-100 leading-relaxed">
                                            {surfaces[surfaceKey].desc}
                                        </p>
                                    </div>
                                </div>
                                <div className="mt-4 flex items-center gap-2 text-xs text-slate-500">
                                    <MousePointer2Icon className="w-3 h-3" />
                                    <span>Double-click surface to move start point</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<GradientDescentVis />);
    </script>
</body>
</html>
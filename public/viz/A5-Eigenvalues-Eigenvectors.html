<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eigenvalues & Eigenvectors</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Inter', sans-serif; color: white; }
        
        .panel {
            background-color: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            border: 1px solid #334155;
        }

        .matrix-input {
            width: 40px; height: 30px;
            background: #1e293b; border: 1px solid #475569;
            color: white; text-align: center; font-family: monospace;
            border-radius: 4px;
        }
        .matrix-input:focus {
            outline: none; border-color: #3b82f6;
        }
        .matrix-bracket {
            position: relative; padding: 0 8px;
        }
        .matrix-bracket::before, .matrix-bracket::after {
            content: ''; position: absolute; top: 0; bottom: 0; width: 6px; border: 2px solid #94a3b8;
        }
        .matrix-bracket::before { left: 0; border-right: 0; }
        .matrix-bracket::after { right: 0; border-left: 0; }

        input[type=range] {
            -webkit-appearance: none; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px;
            border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #334155; border-radius: 2px;
        }

        .glow-yellow { filter: drop-shadow(0 0 8px rgba(250, 204, 21, 0.6)); }
        .glow-cyan { filter: drop-shadow(0 0 8px rgba(34, 211, 238, 0.6)); }
        
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 8px rgba(250, 204, 21, 0.4)); }
            50% { filter: drop-shadow(0 0 16px rgba(250, 204, 21, 0.8)); }
        }
        .animate-glow { animation: pulse-glow 1s ease-in-out infinite; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "../lib/three/three.module.js",
                "three/addons/": "../lib/three/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container" class="absolute inset-0 z-0 bg-slate-900"></div>

    <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-4">
        
        <!-- Top Bar -->
        <div class="flex justify-between items-start gap-4">
            <!-- Left Panel: Controls -->
            <div class="panel p-4 rounded-xl pointer-events-auto shadow-xl max-w-xs">
                <h1 class="text-xl font-bold text-blue-400">Eigen Visualizer</h1>
                <p class="text-xs text-slate-400 mb-4">Explore vectors that only scale under transformation.</p>
                
                <!-- View Toggle -->
                <div class="flex bg-slate-800 rounded p-1 mb-4">
                    <button onclick="app.setMode('matrix')" id="btn-mode-matrix" class="flex-1 text-xs py-1.5 rounded font-bold bg-blue-600 text-white shadow">Matrix Mode</button>
                    <button onclick="app.setMode('pca')" id="btn-mode-pca" class="flex-1 text-xs py-1.5 rounded font-bold text-slate-400 hover:bg-slate-700">PCA Mode</button>
                </div>

                <!-- Matrix Controls -->
                <div id="controls-matrix">
                    <div class="flex items-center gap-4 mb-4">
                        <div class="matrix-bracket flex flex-col gap-1">
                            <div class="flex gap-1">
                                <input id="m00" class="matrix-input" value="2" onchange="app.updateMatrixFromUI()">
                                <input id="m01" class="matrix-input" value="1" onchange="app.updateMatrixFromUI()">
                            </div>
                            <div class="flex gap-1">
                                <input id="m10" class="matrix-input" value="0" onchange="app.updateMatrixFromUI()">
                                <input id="m11" class="matrix-input" value="1" onchange="app.updateMatrixFromUI()">
                            </div>
                        </div>
                        <div class="flex flex-col gap-1">
                            <button onclick="app.setPreset('scale')" class="text-[10px] bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded">Scale (2, 3)</button>
                            <button onclick="app.setPreset('shear')" class="text-[10px] bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded">Shear</button>
                            <button onclick="app.setPreset('rotate')" class="text-[10px] bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded">Rotate 45°</button>
                            <button onclick="app.setPreset('symmetric')" class="text-[10px] bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded">Symmetric</button>
                        </div>
                    </div>

                    <!-- Animation Control -->
                    <div class="flex gap-2 mb-4">
                        <button onclick="app.playTransformation()" id="btn-play" class="flex-1 text-xs bg-green-600 hover:bg-green-500 text-white py-2 rounded font-bold flex items-center justify-center gap-1">
                            <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/></svg>
                            Play Transform
                        </button>
                        <button onclick="app.resetTransformation()" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-2 rounded font-bold">Reset</button>
                    </div>

                    <!-- Transformation Slider -->
                    <div class="mb-4">
                        <div class="flex justify-between text-[10px] text-slate-400 mb-1">
                            <span>Identity (I)</span>
                            <span>Transform (A)</span>
                        </div>
                        <input type="range" id="transform-t" min="0" max="1" step="0.01" value="1" class="w-full" oninput="app.setTransformT(this.value)">
                    </div>

                    <div class="border-t border-slate-700 pt-3">
                        <h3 class="text-xs font-bold text-slate-300 mb-2">Eigenvalues & Eigenvectors</h3>
                        <div id="eigen-results" class="space-y-2 text-xs font-mono"></div>
                    </div>

                    <!-- Characteristic Equation -->
                    <div id="char-equation" class="border-t border-slate-700 pt-3 mt-3">
                        <h3 class="text-xs font-bold text-slate-300 mb-2">Characteristic Equation</h3>
                        <div id="char-eq-content" class="text-[10px] text-slate-400 font-mono"></div>
                    </div>
                </div>

                <!-- PCA Controls -->
                <div id="controls-pca" class="hidden">
                    <p class="text-xs text-slate-400 mb-3">Eigenvectors of covariance matrix reveal directions of maximum variance.</p>
                    <div class="space-y-2 mb-4">
                        <button onclick="app.pca.generateData()" class="w-full text-xs bg-blue-600 hover:bg-blue-500 text-white py-2 rounded font-bold">Generate New Data</button>
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] text-slate-400 w-16">Spread X</span>
                            <input type="range" id="pca-spread-x" min="0.5" max="4" step="0.1" value="3" class="flex-1" oninput="app.pca.generateData()">
                            <span id="pca-spread-x-val" class="text-[10px] text-slate-300 w-6">3.0</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] text-slate-400 w-16">Spread Y</span>
                            <input type="range" id="pca-spread-y" min="0.5" max="4" step="0.1" value="1" class="flex-1" oninput="app.pca.generateData()">
                            <span id="pca-spread-y-val" class="text-[10px] text-slate-300 w-6">1.0</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] text-slate-400 w-16">Rotation</span>
                            <input type="range" id="pca-tilt" min="-90" max="90" step="1" value="30" class="flex-1" oninput="app.pca.generateData()">
                            <span id="pca-tilt-val" class="text-[10px] text-slate-300 w-6">30°</span>
                        </div>
                    </div>
                    <div class="border-t border-slate-700 pt-3">
                        <h3 class="text-xs font-bold text-slate-300 mb-2">Principal Components</h3>
                        <div id="pca-results" class="space-y-2 text-xs"></div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Legend -->
            <div class="panel p-3 rounded-xl pointer-events-auto shadow-xl" id="legend-panel">
                <h3 class="text-xs font-bold text-slate-300 mb-2">Legend</h3>
                <div class="space-y-1 text-[10px]">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-0.5 bg-yellow-400"></div>
                        <span class="text-slate-300">Eigenvector 1 (λ₁)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-0.5 bg-cyan-400"></div>
                        <span class="text-slate-300">Eigenvector 2 (λ₂)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-0.5 bg-slate-500"></div>
                        <span class="text-slate-300">Original Grid</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-0.5 bg-blue-500"></div>
                        <span class="text-slate-300">Transformed Grid</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Status -->
        <div class="flex justify-center">
            <div id="status-bar" class="panel px-6 py-3 rounded-full pointer-events-auto shadow-2xl flex items-center gap-4 transition-all">
                <div class="text-center">
                    <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold">Probe Direction</div>
                    <div id="status-msg" class="text-sm font-bold text-white">Move mouse to explore</div>
                </div>
                <div class="h-8 w-px bg-slate-600"></div>
                <div class="text-center">
                    <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold">Scaling Factor</div>
                    <div id="status-lambda" class="text-lg font-mono text-slate-300">—</div>
                </div>
                <div class="h-8 w-px bg-slate-600"></div>
                <div class="text-center">
                    <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold">Alignment</div>
                    <div id="status-alignment" class="text-sm font-bold text-slate-300">—</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Math Utilities
        const MathUtils = {
            solveEigenvalues: (a, b, c, d) => {
                const tr = a + d;
                const det = a * d - b * c;
                const discriminant = tr * tr - 4 * det;

                if (discriminant < -0.0001) return { real: [], complex: true, discriminant };
                
                const sqrtDisc = Math.sqrt(Math.max(0, discriminant));
                const l1 = (tr + sqrtDisc) / 2;
                const l2 = (tr - sqrtDisc) / 2;
                
                if (Math.abs(l1 - l2) < 0.0001) return { real: [l1], complex: false, discriminant };
                return { real: [l1, l2], complex: false, discriminant };
            },

            getEigenvector: (a, b, c, d, lambda) => {
                const m00 = a - lambda;
                const m01 = b;
                const m10 = c;
                const m11 = d - lambda;

                if (Math.abs(m01) > 0.0001) {
                    return new THREE.Vector3(m01, -m00, 0).normalize();
                }
                if (Math.abs(m10) > 0.0001) {
                    return new THREE.Vector3(-m11, m10, 0).normalize();
                }
                if (Math.abs(lambda - a) < 0.0001) return new THREE.Vector3(1, 0, 0);
                if (Math.abs(lambda - d) < 0.0001) return new THREE.Vector3(0, 1, 0);
                
                return new THREE.Vector3(1, 0, 0);
            },

            lerpColor: (c1, c2, t) => {
                const color1 = new THREE.Color(c1);
                const color2 = new THREE.Color(c2);
                return color1.lerp(color2, t);
            }
        };

        class MainApp {
            constructor() {
                this.matrix = { a: 2, b: 1, c: 0, d: 1 };
                this.eigenData = [];
                this.mode = 'matrix';
                this.transformT = 1;
                this.isAnimating = false;
                
                this.initThree();
                this.grid = new DeformingGrid(this.scene);
                this.probe = new Probe(this.scene, this.camera, this);
                this.pca = new PCAVisualizer(this.scene);

                this.updateMatrixFromUI();
                this.animate();

                // Mouse interaction (probe follow is toggled with keyboard in Matrix Mode)
                window.addEventListener('mousemove', (e) => this.probe.onMouseMove(e));
                window.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.probe.onMouseMove(e.touches[0]);
                }, { passive: false });

                // Keyboard toggle for probe follow in Matrix Mode (press 'F')
                window.addEventListener('keydown', (e) => {
                    if (this.mode === 'matrix' && (e.key === 'f' || e.key === 'F')) {
                        this.probe.followEnabled = !this.probe.followEnabled;
                    }
                });
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f172a);

                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 12;
                this.camera = new THREE.OrthographicCamera(
                    frustumSize * aspect / -2, frustumSize * aspect / 2,
                    frustumSize / 2, frustumSize / -2,
                    1, 1000
                );
                this.camera.position.set(0, 0, 10);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.labelRenderer = new CSS2DRenderer();
                this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
                this.labelRenderer.domElement.style.position = 'absolute';
                this.labelRenderer.domElement.style.top = '0';
                this.labelRenderer.domElement.style.pointerEvents = 'none';
                document.getElementById('canvas-container').appendChild(this.labelRenderer.domElement);

                // Subtle grid background
                const gridHelper = new THREE.GridHelper(20, 20, 0x1e293b, 0x1e293b);
                gridHelper.rotation.x = Math.PI / 2;
                this.scene.add(gridHelper);

                window.addEventListener('resize', () => {
                    const aspect = window.innerWidth / window.innerHeight;
                    this.camera.left = -frustumSize * aspect / 2;
                    this.camera.right = frustumSize * aspect / 2;
                    this.camera.top = frustumSize / 2;
                    this.camera.bottom = -frustumSize / 2;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setMode(mode) {
                this.mode = mode;
                
                const btnMat = document.getElementById('btn-mode-matrix');
                const btnPca = document.getElementById('btn-mode-pca');
                const ctrlMat = document.getElementById('controls-matrix');
                const ctrlPca = document.getElementById('controls-pca');
                const legend = document.getElementById('legend-panel');

                if (mode === 'matrix') {
                    btnMat.className = "flex-1 text-xs py-1.5 rounded font-bold bg-blue-600 text-white shadow";
                    btnPca.className = "flex-1 text-xs py-1.5 rounded font-bold text-slate-400 hover:bg-slate-700";
                    ctrlMat.classList.remove('hidden');
                    ctrlPca.classList.add('hidden');
                    legend.classList.remove('hidden');
                    
                    this.grid.setVisible(true);
                    this.probe.setVisible(true);
                    this.pca.setVisible(false);
                    this.updateMatrixFromUI();
                } else {
                    btnPca.className = "flex-1 text-xs py-1.5 rounded font-bold bg-blue-600 text-white shadow";
                    btnMat.className = "flex-1 text-xs py-1.5 rounded font-bold text-slate-400 hover:bg-slate-700";
                    ctrlPca.classList.remove('hidden');
                    ctrlMat.classList.add('hidden');
                    legend.classList.add('hidden');

                    this.grid.setVisible(false);
                    this.probe.setVisible(false);
                    this.probe.followEnabled = false;
                    this.pca.setVisible(true);
                    this.pca.generateData();
                }
            }

            setPreset(type) {
                let m = {a:1, b:0, c:0, d:1};
                if(type === 'scale') m = {a:2, b:0, c:0, d:3};
                if(type === 'shear') m = {a:1, b:1, c:0, d:1};
                if(type === 'rotate') {
                    const angle = Math.PI / 4;
                    m = {a: Math.cos(angle), b: -Math.sin(angle), c: Math.sin(angle), d: Math.cos(angle)};
                }
                if(type === 'symmetric') m = {a:2, b:1, c:1, d:2};

                document.getElementById('m00').value = m.a.toFixed(2);
                document.getElementById('m01').value = m.b.toFixed(2);
                document.getElementById('m10').value = m.c.toFixed(2);
                document.getElementById('m11').value = m.d.toFixed(2);
                
                this.updateMatrixFromUI();
            }

            setTransformT(t) {
                this.transformT = parseFloat(t);
                this.updateVisuals();
            }

            playTransformation() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                
                const btn = document.getElementById('btn-play');
                btn.innerHTML = '<svg class="w-3 h-3 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Playing...';
                
                const slider = document.getElementById('transform-t');
                
                new TWEEN.Tween({ t: 0 })
                    .to({ t: 1 }, 2000)
                    .easing(TWEEN.Easing.Cubic.InOut)
                    .onUpdate(({ t }) => {
                        this.transformT = t;
                        slider.value = t;
                        this.updateVisuals();
                    })
                    .onComplete(() => {
                        this.isAnimating = false;
                        btn.innerHTML = '<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/></svg> Play Transform';
                    })
                    .start();
            }

            resetTransformation() {
                this.transformT = 0;
                document.getElementById('transform-t').value = 0;
                this.updateVisuals();
            }

            updateMatrixFromUI() {
                const a = parseFloat(document.getElementById('m00').value) || 0;
                const b = parseFloat(document.getElementById('m01').value) || 0;
                const c = parseFloat(document.getElementById('m10').value) || 0;
                const d = parseFloat(document.getElementById('m11').value) || 0;
                this.matrix = { a, b, c, d };

                // Compute eigenvalues
                const result = MathUtils.solveEigenvalues(a, b, c, d);
                
                if (result.complex) {
                    this.eigenData = [];
                } else {
                    this.eigenData = result.real.map(l => ({
                        lambda: l,
                        vector: MathUtils.getEigenvector(a, b, c, d, l)
                    }));
                }

                this.updateVisuals();
                this.renderEigenResults(result);
                this.renderCharacteristicEquation();
            }

            updateVisuals() {
                // Interpolate from Identity to Matrix
                const t = this.transformT;
                const interp = {
                    a: 1 + t * (this.matrix.a - 1),
                    b: t * this.matrix.b,
                    c: t * this.matrix.c,
                    d: 1 + t * (this.matrix.d - 1)
                };

                this.grid.update(interp, this.eigenData);
                this.probe.update(interp, this.eigenData);
            }

            renderEigenResults(result) {
                const container = document.getElementById('eigen-results');
                container.innerHTML = '';

                if (result.complex) {
                    container.innerHTML = `
                        <div class="bg-slate-800/50 rounded p-2">
                            <div class="text-slate-400 text-[10px] mb-1">Complex eigenvalues (pure rotation)</div>
                            <div class="text-purple-400">No real eigenvectors exist</div>
                            <div class="text-[10px] text-slate-500 mt-1">Every vector rotates under this transformation</div>
                        </div>`;
                    return;
                }

                this.eigenData.forEach((ed, i) => {
                    const col = i === 0 ? 'yellow' : 'cyan';
                    const v = ed.vector;
                    const l = ed.lambda;
                    
                    let interpretation = '';
                    if (l > 1) interpretation = `stretches ${l.toFixed(1)}×`;
                    else if (l > 0 && l < 1) interpretation = `compresses to ${(l*100).toFixed(0)}%`;
                    else if (l === 1) interpretation = 'unchanged';
                    else if (l < 0 && l > -1) interpretation = `flips & compresses`;
                    else if (l < -1) interpretation = `flips & stretches ${Math.abs(l).toFixed(1)}×`;
                    else if (l === 0) interpretation = 'collapses to 0';
                    
                    const div = document.createElement('div');
                    div.className = 'bg-slate-800/50 rounded p-2';
                    div.innerHTML = `
                        <div class="flex items-center gap-2 mb-1">
                            <div class="w-3 h-3 rounded-full bg-${col}-400"></div>
                            <span class="text-${col}-400 font-bold">λ${i+1} = ${l.toFixed(3)}</span>
                        </div>
                        <div class="text-slate-400 text-[10px]">
                            Direction: [${v.x.toFixed(2)}, ${v.y.toFixed(2)}]
                        </div>
                        <div class="text-slate-500 text-[10px]">${interpretation}</div>
                    `;
                    container.appendChild(div);
                });
            }

            renderCharacteristicEquation() {
                const { a, b, c, d } = this.matrix;
                const tr = a + d;
                const det = a * d - b * c;
                
                const content = document.getElementById('char-eq-content');
                content.innerHTML = `
                    <div class="space-y-1">
                        <div>det(A - λI) = 0</div>
                        <div>λ² - ${tr.toFixed(2)}λ + ${det.toFixed(2)} = 0</div>
                        <div class="text-slate-500">trace = ${tr.toFixed(2)}, det = ${det.toFixed(2)}</div>
                    </div>
                `;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                TWEEN.update();
                this.renderer.render(this.scene, this.camera);
                this.labelRenderer.render(this.scene, this.camera);
            }
        }

        // Deforming Grid Visualization
        class DeformingGrid {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.scene.add(this.group);
                
                this.originalLines = [];
                this.transformedLines = [];
                this.eigenLines = [];
                
                this.createGrid();
            }

            createGrid() {
                const range = 5;
                
                // Create original grid lines (faint)
                const originalMat = new THREE.LineBasicMaterial({ color: 0x334155, opacity: 0.5, transparent: true });
                
                // Vertical lines
                for (let x = -range; x <= range; x++) {
                    const points = [];
                    for (let y = -range; y <= range; y += 0.5) {
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geo, originalMat);
                    this.group.add(line);
                    this.originalLines.push({ line, points: points.map(p => p.clone()), type: 'v', coord: x });
                }
                
                // Horizontal lines
                for (let y = -range; y <= range; y++) {
                    const points = [];
                    for (let x = -range; x <= range; x += 0.5) {
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geo, originalMat);
                    this.group.add(line);
                    this.originalLines.push({ line, points: points.map(p => p.clone()), type: 'h', coord: y });
                }

                // Create transformed grid lines
                const transformedMat = new THREE.LineBasicMaterial({ color: 0x3b82f6, linewidth: 2 });
                
                // Vertical lines
                for (let x = -range; x <= range; x++) {
                    const points = [];
                    for (let y = -range; y <= range; y += 0.2) {
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geo, transformedMat.clone());
                    this.group.add(line);
                    this.transformedLines.push({ line, basePoints: points.map(p => p.clone()) });
                }
                
                // Horizontal lines
                for (let y = -range; y <= range; y++) {
                    const points = [];
                    for (let x = -range; x <= range; x += 0.2) {
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geo, transformedMat.clone());
                    this.group.add(line);
                    this.transformedLines.push({ line, basePoints: points.map(p => p.clone()) });
                }

                // Axes (brighter)
                const axesMat = new THREE.LineBasicMaterial({ color: 0x64748b });
                const xAxis = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-range, 0, 0), new THREE.Vector3(range, 0, 0)]),
                    axesMat
                );
                const yAxis = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -range, 0), new THREE.Vector3(0, range, 0)]),
                    axesMat
                );
                this.group.add(xAxis, yAxis);
            }

            setVisible(val) {
                this.group.visible = val;
            }

            update(matrix, eigenData) {
                const m = matrix;

                // Update transformed grid
                this.transformedLines.forEach(item => {
                    const positions = item.line.geometry.attributes.position.array;
                    
                    item.basePoints.forEach((p, i) => {
                        const tx = m.a * p.x + m.b * p.y;
                        const ty = m.c * p.x + m.d * p.y;
                        positions[i * 3] = tx;
                        positions[i * 3 + 1] = ty;
                        positions[i * 3 + 2] = 0;
                    });
                    
                    item.line.geometry.attributes.position.needsUpdate = true;
                });

                // Update eigenvector lines
                this.eigenLines.forEach(l => this.group.remove(l));
                this.eigenLines = [];

                eigenData.forEach((ed, i) => {
                    const color = i === 0 ? 0xfacc15 : 0x22d3ee;
                    const mat = new THREE.LineDashedMaterial({ 
                        color: color, 
                        dashSize: 0.3, 
                        gapSize: 0.15,
                        linewidth: 2
                    });
                    
                    const points = [
                        ed.vector.clone().multiplyScalar(-20),
                        ed.vector.clone().multiplyScalar(20)
                    ];
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geo, mat);
                    line.computeLineDistances();
                    this.group.add(line);
                    this.eigenLines.push(line);
                });
            }
        }

        // Interactive Probe
        class Probe {
            constructor(scene, camera, app) {
                this.scene = scene;
                this.camera = camera;
                this.app = app;
                
                this.group = new THREE.Group();
                this.scene.add(this.group);

                // Whether the probe should follow the cursor (toggled in Matrix Mode)
                this.followEnabled = false;
                
                // Input Vector (shows current mouse direction/position)
                this.inputVec = new THREE.Vector3(1, 0, 0);
                this.inputArrow = new THREE.ArrowHelper(
                    this.inputVec, 
                    new THREE.Vector3(0, 0, 0.1), 
                    2, 
                    0x94a3b8, 
                    0.3, 
                    0.2
                );
                this.group.add(this.inputArrow);

                // Output Vector (transformed result)
                this.outputArrow = new THREE.ArrowHelper(
                    this.inputVec, 
                    new THREE.Vector3(0, 0, 0.05), 
                    2, 
                    0xc084fc, 
                    0.3, 
                    0.2
                );
                this.group.add(this.outputArrow);

                // Labels
                this.inputLabel = this.createLabel('v', 0x94a3b8);
                this.outputLabel = this.createLabel('Av', 0xc084fc);
                this.group.add(this.inputLabel);
                this.group.add(this.outputLabel);
            }

            createLabel(text, color) {
                const div = document.createElement('div');
                div.className = 'text-xs px-1.5 py-0.5 rounded font-mono font-bold';
                div.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}33`;
                div.style.color = `#${color.toString(16).padStart(6, '0')}`;
                div.style.border = `1px solid #${color.toString(16).padStart(6, '0')}66`;
                div.textContent = text;
                return new CSS2DObject(div);
            }

            setVisible(val) {
                this.group.visible = val;
            }

            onMouseMove(e) {
                if (!this.group.visible || !this.followEnabled) return;
                
                const rect = this.app.renderer.domElement.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                const vec = new THREE.Vector3(x, y, 0);
                vec.unproject(this.camera);
                vec.z = 0;
                
                // Always follow the cursor: store the full position vector
                this.inputVec.copy(vec);
                this.update(this.currentMatrix, this.currentEigenData);
            }

            update(matrix, eigenData) {
                if (!matrix) return;
                
                this.currentMatrix = matrix;
                this.currentEigenData = eigenData || [];
                
                const m = matrix;
                const ix = this.inputVec.x;
                const iy = this.inputVec.y;
                
                // Transform the input vector
                const tx = m.a * ix + m.b * iy;
                const ty = m.c * ix + m.d * iy;
                const outputVec = new THREE.Vector3(tx, ty, 0);

                // Direction (unit) for comparisons
                const inDir = this.inputVec.clone();
                const inLen = inDir.length();
                if (inLen > 0.0001) {
                    inDir.divideScalar(inLen);
                } else {
                    inDir.set(1, 0, 0);
                }

                // Calculate alignment with eigenvectors
                let minAngle = Math.PI;
                let closestEigen = null;
                
                this.currentEigenData.forEach((ed, i) => {
                    let angle = inDir.angleTo(ed.vector);
                    // Check opposite direction too
                    if (angle > Math.PI / 2) angle = Math.PI - angle;
                    if (angle < minAngle) {
                        minAngle = angle;
                        closestEigen = { ...ed, index: i };
                    }
                });

                // Warmth: how close to an eigenvector (0 = cold, 1 = hot)
                const warmthThreshold = Math.PI / 6; // 30 degrees
                const warmth = Math.max(0, 1 - minAngle / warmthThreshold);
                const isEigen = minAngle < 0.03; // ~1.7 degrees

                // Update input arrow color based on warmth
                const coldColor = 0x64748b;
                const hotColor = closestEigen ? (closestEigen.index === 0 ? 0xfacc15 : 0x22d3ee) : 0xfacc15;
                const inputColor = MathUtils.lerpColor(coldColor, hotColor, warmth);
                this.inputArrow.setColor(inputColor);

                // Update input arrow so its head goes through the cursor position
                if (inLen > 0.0001) {
                    this.inputArrow.setDirection(inDir);
                    this.inputArrow.setLength(inLen, 0.3, 0.2);
                } else {
                    this.inputArrow.setDirection(new THREE.Vector3(1, 0, 0));
                    this.inputArrow.setLength(0.0001, 0.3, 0.2);
                }

                const outputLen = outputVec.length();
                if (outputLen > 0.001) {
                    this.outputArrow.visible = true;
                    this.outputArrow.setDirection(outputVec.clone().normalize());
                    this.outputArrow.setLength(outputLen, 0.3, 0.2);
                    
                    // Color output based on whether it aligns with input
                    if (isEigen) {
                        this.outputArrow.setColor(hotColor);
                    } else {
                        this.outputArrow.setColor(0xa855f7); // Purple for rotated
                    }
                } else {
                    this.outputArrow.visible = false;
                }

                // Update labels (slightly past the arrow heads)
                this.inputLabel.position.copy(inDir.clone().multiplyScalar(inLen + 0.3));
                if (outputLen > 0.001) {
                    this.outputLabel.position.copy(
                        outputVec.clone().normalize().multiplyScalar(outputLen + 0.3)
                    );
                }
                this.outputLabel.visible = this.outputArrow.visible && !isEigen;

                // Update status bar
                const statusMsg = document.getElementById('status-msg');
                const statusLambda = document.getElementById('status-lambda');
                const statusAlign = document.getElementById('status-alignment');

                if (isEigen && closestEigen && inLen > 0.0001) {
                    const sign = this.inputVec.dot(outputVec) < 0 ? -1 : 1;
                    const lambda = (outputLen / inLen) * sign;
                    
                    statusMsg.innerText = "EIGENVECTOR!";
                    statusMsg.className = "text-sm font-bold text-yellow-400";
                    statusLambda.innerText = `λ = ${lambda.toFixed(2)}`;
                    statusLambda.className = "text-lg font-mono text-yellow-400";
                    statusAlign.innerText = "Perfect ✓";
                    statusAlign.className = "text-sm font-bold text-green-400";
                    
                    this.inputLabel.element.textContent = `λ=${lambda.toFixed(2)}`;
                    this.inputLabel.element.style.backgroundColor = `#${hotColor.toString(16).padStart(6, '0')}44`;
                    this.inputLabel.element.style.color = `#${hotColor.toString(16).padStart(6, '0')}`;
                    this.inputLabel.element.style.borderColor = `#${hotColor.toString(16).padStart(6, '0')}`;
                } else {
                    statusMsg.innerText = "Exploring...";
                    statusMsg.className = "text-sm font-bold text-slate-300";
                    statusLambda.innerText = `|Av| = ${outputLen.toFixed(2)}`;
                    statusLambda.className = "text-lg font-mono text-slate-300";
                    
                    // Show warmth percentage
                    if (warmth > 0.1) {
                        statusAlign.innerText = `${(warmth * 100).toFixed(0)}% aligned`;
                        statusAlign.className = "text-sm font-bold text-amber-400";
                    } else {
                        statusAlign.innerText = "Rotating";
                        statusAlign.className = "text-sm font-bold text-purple-400";
                    }
                    
                    this.inputLabel.element.textContent = 'v';
                    this.inputLabel.element.style.backgroundColor = '#64748b33';
                    this.inputLabel.element.style.color = '#94a3b8';
                    this.inputLabel.element.style.borderColor = '#64748b66';
                }
            }
        }

        // PCA Visualizer
        class PCAVisualizer {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.scene.add(this.group);
                this.group.visible = false;
                
                this.points = null;
                this.pc1Arrow = null;
                this.pc2Arrow = null;
                this.ellipse = null;
            }

            setVisible(val) {
                this.group.visible = val;
            }

            generateData() {
                const spreadX = parseFloat(document.getElementById('pca-spread-x').value);
                const spreadY = parseFloat(document.getElementById('pca-spread-y').value);
                const tiltDeg = parseFloat(document.getElementById('pca-tilt').value);
                const tilt = tiltDeg * Math.PI / 180;

                // Update display values
                document.getElementById('pca-spread-x-val').textContent = spreadX.toFixed(1);
                document.getElementById('pca-spread-y-val').textContent = spreadY.toFixed(1);
                document.getElementById('pca-tilt-val').textContent = `${tiltDeg.toFixed(0)}°`;

                const cos = Math.cos(tilt);
                const sin = Math.sin(tilt);

                const count = 200;
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                
                let sumX = 0, sumY = 0;
                const data = [];

                // Box-Muller for better Gaussian
                const randn = () => {
                    let u = 0, v = 0;
                    while (u === 0) u = Math.random();
                    while (v === 0) v = Math.random();
                    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                };

                for (let i = 0; i < count; i++) {
                    const sx = randn() * spreadX;
                    const sy = randn() * spreadY;
                    
                    const rx = sx * cos - sy * sin;
                    const ry = sx * sin + sy * cos;
                    
                    positions[i * 3] = rx;
                    positions[i * 3 + 1] = ry;
                    positions[i * 3 + 2] = 0;
                    
                    // Color based on distance from origin
                    const dist = Math.sqrt(rx * rx + ry * ry);
                    const t = Math.min(dist / 4, 1);
                    colors[i * 3] = 0.4 + t * 0.3;     // R
                    colors[i * 3 + 1] = 0.5 + t * 0.3; // G
                    colors[i * 3 + 2] = 0.9;           // B
                    
                    data.push({ x: rx, y: ry });
                    sumX += rx;
                    sumY += ry;
                }

                // Render points
                if (this.points) this.group.remove(this.points);
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({ size: 0.12, vertexColors: true });
                this.points = new THREE.Points(geo, mat);
                this.group.add(this.points);

                // Calculate covariance
                const meanX = sumX / count;
                const meanY = sumY / count;
                
                let covXX = 0, covXY = 0, covYY = 0;
                for (let p of data) {
                    covXX += (p.x - meanX) * (p.x - meanX);
                    covXY += (p.x - meanX) * (p.y - meanY);
                    covYY += (p.y - meanY) * (p.y - meanY);
                }
                covXX /= (count - 1);
                covXY /= (count - 1);
                covYY /= (count - 1);

                // Eigen decomposition
                const result = MathUtils.solveEigenvalues(covXX, covXY, covXY, covYY);
                const lambdas = result.real;
                
                if (lambdas.length >= 2) {
                    const v1 = MathUtils.getEigenvector(covXX, covXY, covXY, covYY, lambdas[0]);
                    const v2 = MathUtils.getEigenvector(covXX, covXY, covXY, covYY, lambdas[1]);

                    // Draw arrows scaled by sqrt(eigenvalue) = std dev
                    this.updateArrow(1, v1, Math.sqrt(lambdas[0]));
                    this.updateArrow(2, v2, Math.sqrt(lambdas[1]));

                    // Draw confidence ellipse
                    this.drawEllipse(Math.sqrt(lambdas[0]) * 2, Math.sqrt(lambdas[1]) * 2, tilt);

                    // Update results panel
                    const total = lambdas[0] + lambdas[1];
                    const pct1 = ((lambdas[0] / total) * 100).toFixed(1);
                    const pct2 = ((lambdas[1] / total) * 100).toFixed(1);

                    document.getElementById('pca-results').innerHTML = `
                        <div class="bg-slate-800/50 rounded p-2">
                            <div class="flex items-center gap-2 mb-1">
                                <div class="w-3 h-3 rounded-full bg-yellow-400"></div>
                                <span class="text-yellow-400 font-bold font-mono">PC1</span>
                                <span class="text-slate-400 text-[10px]">${pct1}% variance</span>
                            </div>
                            <div class="text-[10px] text-slate-500">λ₁ = ${lambdas[0].toFixed(3)}, σ₁ = ${Math.sqrt(lambdas[0]).toFixed(2)}</div>
                        </div>
                        <div class="bg-slate-800/50 rounded p-2">
                            <div class="flex items-center gap-2 mb-1">
                                <div class="w-3 h-3 rounded-full bg-cyan-400"></div>
                                <span class="text-cyan-400 font-bold font-mono">PC2</span>
                                <span class="text-slate-400 text-[10px]">${pct2}% variance</span>
                            </div>
                            <div class="text-[10px] text-slate-500">λ₂ = ${lambdas[1].toFixed(3)}, σ₂ = ${Math.sqrt(lambdas[1]).toFixed(2)}</div>
                        </div>
                        <div class="text-[10px] text-slate-500 mt-2">
                            Eigenvectors of covariance matrix point in directions of maximum spread.
                        </div>
                    `;
                } else {
                    document.getElementById('pca-results').innerHTML = `
                        <div class="text-[10px] text-red-400">Could not compute two principal components.</div>
                    `;
                }
            }

            updateArrow(id, dir, length) {
                const color = id === 1 ? 0xfacc15 : 0x22d3ee;
                const name = `pc${id}Arrow`;
                
                if (this[name]) this.group.remove(this[name]);
                
                const visualLen = length * 2;
                if (visualLen < 0.1) return;

                this[name] = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0.1), visualLen, color, 0.25, 0.15);
                this.group.add(this[name]);
            }

            drawEllipse(rx, ry, rotation) {
                if (this.ellipse) this.group.remove(this.ellipse);
                
                const curve = new THREE.EllipseCurve(0, 0, rx, ry, 0, 2 * Math.PI, false, rotation);
                const points = curve.getPoints(64);
                const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, p.y, 0)));
                const mat = new THREE.LineBasicMaterial({ color: 0x64748b, opacity: 0.5, transparent: true });
                this.ellipse = new THREE.Line(geo, mat);
                this.group.add(this.ellipse);
            }
        }

        // Initialize app and expose globally for inline handlers
        const app = new MainApp();
        window.app = app;
    </script>
</body>
</html>

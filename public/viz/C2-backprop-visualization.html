<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C2: Backpropagation Walkthrough</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Top Header */
        header {
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: auto;
        }
        h1 { margin: 0; font-size: 1.5rem; color: #4facfe; text-shadow: 0 0 10px rgba(79, 172, 254, 0.5); }
        .subtitle { margin: 5px 0 0; color: #aaa; font-size: 0.9rem; max-width: 600px; }

        /* Controls Panel */
        #controls {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            pointer-events: auto;
            width: 280px;
            backdrop-filter: blur(5px);
        }
        
        .control-group { margin-bottom: 15px; }
        .control-group:last-child { margin-bottom: 0; }
        label { display: block; font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        input[type="range"] { width: 100%; cursor: pointer; }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        button:hover:not(:disabled) { background: #333; border-color: #666; }
        button.primary { background: #0066cc; border-color: #0055aa; }
        button.primary:hover:not(:disabled) { background: #0077dd; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-row { display: flex; gap: 5px; margin-top: 5px; }
        .btn-row button { flex: 1; }

        hr { border: none; border-top: 1px solid #444; margin: 15px 0; }

        /* Progress Bar */
        .progress-container {
            background: #222;
            border-radius: 4px;
            padding: 8px 10px;
            margin-top: 10px;
        }
        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 5px;
        }
        .progress-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff8e53);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Status */
        .status-box {
            font-size: 0.8em;
            color: #4facfe;
            margin-top: 10px;
            padding: 8px;
            background: rgba(79, 172, 254, 0.1);
            border-radius: 4px;
            border-left: 3px solid #4facfe;
        }

        /* Math/Chain Rule Panel */
        #math-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.95);
            padding: 20px 30px;
            border-radius: 12px;
            border: 1px solid #444;
            min-width: 500px;
            max-width: 700px;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }
        #math-panel.visible { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0);
        }
        
        .math-title { 
            color: #ff6b6b; 
            font-size: 0.85rem; 
            text-transform: uppercase; 
            letter-spacing: 2px; 
            margin-bottom: 12px;
            font-weight: bold;
        }
        .equation { 
            font-size: 1.5rem; 
            font-family: 'Courier New', monospace; 
            margin: 12px 0; 
            color: #fff;
            line-height: 1.4;
        }
        .substitution { 
            font-size: 1.1rem; 
            color: #aaa; 
            margin: 8px 0;
            font-family: 'Courier New', monospace;
        }
        .result-val { 
            color: #4cd964; 
            font-weight: bold;
            font-size: 1.3rem;
            margin-top: 10px;
        }
        .step-desc { 
            font-size: 0.9rem; 
            color: #888; 
            font-style: italic; 
            margin-top: 12px;
            border-top: 1px solid #333;
            padding-top: 12px;
        }

        /* Local Gradient Reference */
        #local-gradient-box {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            width: 220px;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }
        .local-grad-title {
            font-size: 0.8rem;
            color: #ff6b6b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .local-grad-item {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            transition: all 0.3s;
        }
        .local-grad-item.active {
            background: rgba(255, 107, 107, 0.2);
            border-left: 3px solid #ff6b6b;
        }
        .local-grad-item .op { color: #4facfe; }
        .local-grad-item .deriv { color: #aaa; }

        /* Network Values Display */
        #network-values {
            position: absolute;
            top: 320px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            width: 220px;
            backdrop-filter: blur(5px);
            pointer-events: auto;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }
        .values-title {
            font-size: 0.8rem;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
        }
        .value-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid #222;
        }
        .value-row:last-child { border-bottom: none; }
        .value-label { color: #888; }
        .value-num { color: #fff; }
        .value-grad { color: #ff6b6b; }

        /* Floating Labels */
        .label {
            position: absolute;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: rgba(0,0,0,0.8);
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none;
            user-select: none;
            transform: translate(-50%, -50%);
            transition: opacity 0.2s, background 0.3s;
            white-space: nowrap;
        }
        .label.grad { 
            color: #ff6b6b; 
            border: 1px solid #ff6b6b; 
            font-weight: bold; 
            z-index: 10;
            background: rgba(255, 107, 107, 0.15);
        }
        .label.val { color: #4facfe; }
        .label.weight {
            color: #aaa;
            font-size: 10px;
            background: rgba(50, 50, 60, 0.9);
        }
        .label.bias {
            color: #9b59b6;
            font-size: 10px;
        }
        
        /* Legend */
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 12px 15px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 6px; }
        .legend-item:last-child { margin-bottom: 0; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; flex-shrink: 0; }
        
        /* Tooltip for hovering */
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.95);
            border: 1px solid #555;
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            font-size: 0.85rem;
            min-width: 180px;
        }
        #tooltip strong { color: #4facfe; }
        #tooltip .tt-row { margin: 4px 0; }
        #tooltip .tt-label { color: #888; }
        #tooltip .tt-val { color: #fff; float: right; font-family: monospace; }

    </style>
    <script src="../lib/three-r128/three.min.js"></script>
    <script src="../lib/three-r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-layer">
    <header>
        <h1>C2: Backpropagation Walkthrough</h1>
        <p class="subtitle">Step through the Chain Rule to see how error gradients flow backward through the network.</p>
    </header>

    <div id="controls">
        <div class="control-group">
            <label>Target Output: <span id="target-val">1.0</span></label>
            <input type="range" id="target-slider" min="0" max="1" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <button id="btn-forward" class="primary">1. Run Forward Pass</button>
        </div>
        
        <hr>
        
        <div class="control-group">
            <button id="btn-start-back" disabled>2. Start Backprop</button>
            <div class="btn-row">
                <button id="btn-prev" disabled>◀ Prev</button>
                <button id="btn-next" disabled>Next ▶</button>
            </div>
            <button id="btn-auto" disabled style="margin-top: 5px;">▶ Auto Play</button>
        </div>

        <div class="progress-container" id="progress-container" style="display: none;">
            <div class="progress-label">
                <span>Backprop Progress</span>
                <span id="step-counter">0 / 0</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>

        <hr>
        
        <div class="control-group">
            <button id="btn-reset">Reset All</button>
        </div>

        <div class="status-box">
            <span id="status-text">Ready. Click "Run Forward Pass" to begin.</span>
        </div>
    </div>

    <!-- Local Gradient Reference -->
    <div id="local-gradient-box">
        <div class="local-grad-title">Local Gradients</div>
        <div class="local-grad-item" id="lg-sigmoid">
            <span class="op">σ(z)</span> → <span class="deriv">σ(1-σ)</span>
        </div>
        <div class="local-grad-item" id="lg-multiply">
            <span class="op">y = w·x</span> → <span class="deriv">∂y/∂w = x</span>
        </div>
        <div class="local-grad-item" id="lg-add">
            <span class="op">y = Σxᵢ</span> → <span class="deriv">∂y/∂xᵢ = 1</span>
        </div>
        <div class="local-grad-item" id="lg-loss">
            <span class="op">L = ½(t-y)²</span> → <span class="deriv">∂L/∂y = y-t</span>
        </div>
    </div>

    <!-- Network Values -->
    <div id="network-values">
        <div class="values-title">Network State</div>
        <div id="values-content">
            <!-- Populated dynamically -->
        </div>
    </div>

    <div id="math-panel">
        <div class="math-title" id="math-title">Current Calculation</div>
        <div class="equation" id="math-eq">∂L/∂w = ...</div>
        <div class="substitution" id="math-sub">...</div>
        <div class="result-val" id="math-res"></div>
        <div class="step-desc" id="math-desc">Waiting to start...</div>
    </div>

    <div id="legend">
        <div class="legend-item"><div class="dot" style="background:#4facfe"></div>Forward Signal (Activation)</div>
        <div class="legend-item"><div class="dot" style="background:#ff6b6b"></div>Backward Gradient (Error)</div>
        <div class="legend-item"><div class="dot" style="background:#9b59b6"></div>Bias Terms</div>
        <div class="legend-item"><div class="dot" style="background:#888"></div>Weights</div>
    </div>
    
    <div id="tooltip"></div>
</div>

<script>
/**
 * BACKPROPAGATION VISUALIZATION ENGINE - IMPROVED VERSION
 * 
 * Matches C2 educational content values exactly:
 * - Inputs: x1=0.5, x2=0.8
 * - Weights: w1=0.4, w2=0.3, w3=0.2, w4=0.5, w5=0.6, w6=0.4
 * - Biases: b1=0.1, b2=0.1, b3=0.1
 * - Target: 1.0
 */

// --- CONFIGURATION ---
const CONFIG = {
    colors: {
        background: 0x111111,
        neuron: 0x333344,
        neuronActive: 0x4facfe,
        neuronBack: 0xff6b6b,
        connection: 0x444455,
        signalForward: 0x4facfe,
        signalBackward: 0xff6b6b,
        bias: 0x9b59b6
    },
    dims: {
        layerSpacing: 15,
        neuronSpacing: 6,
        neuronSize: 1.2
    },
    animation: {
        pulseDuration: 400,
        pulseRepeats: 2,
        particleSpeed: 800,
        stepDelay: 1200,        // Delay between auto-play steps
        buttonLockTime: 1000   // How long to disable buttons during animation
    },
    // Network values matching C2 content exactly
    network: {
        inputs: [0.5, 0.8],
        weights: {
            // Input -> Hidden (w1-w4 in C2 notation)
            // w1: x1->h1, w2: x2->h1, w3: x1->h2, w4: x2->h2
            inputToHidden: [
                [0.4, 0.2],  // From x1 to [h1, h2]
                [0.3, 0.5]   // From x2 to [h1, h2]
            ],
            // Hidden -> Output (w5, w6)
            hiddenToOutput: [0.6, 0.4]  // From [h1, h2] to output
        },
        biases: {
            hidden: [0.1, 0.1],
            output: 0.1
        }
    }
};

// --- DATA STRUCTURES ---
class Neuron {
    constructor(id, layerIndex, indexInLayer, type) {
        this.id = id;
        this.layerIndex = layerIndex;
        this.indexInLayer = indexInLayer;
        this.type = type; // 'input', 'hidden', 'output'
        this.mesh = null;
        this.output = 0;        // a (activation)
        this.inputSum = 0;      // z (pre-activation)
        this.delta = 0;         // δ (error term)
        this.bias = 0;          // b
        this.biasGradient = 0;  // ∂L/∂b
        this.position = new THREE.Vector3();
        this.connectionsIn = [];
        this.connectionsOut = [];
        this.labelElement = null;
        this.gradLabelElement = null;
        this.name = '';
    }
}

class Connection {
    constructor(source, target, weight, weightName) {
        this.source = source;
        this.target = target;
        this.weight = weight;
        this.weightName = weightName;
        this.mesh = null;
        this.gradient = 0;
        this.labelElement = null;
    }
}

// --- NEURAL NETWORK MATH ---
class NeuralNetworkMath {
    static sigmoid(x) { 
        return 1 / (1 + Math.exp(-x)); 
    }
    
    static sigmoidPrime(x) { 
        const s = NeuralNetworkMath.sigmoid(x); 
        return s * (1 - s); 
    }
    
    static squaredErrorLoss(target, output) {
        return 0.5 * Math.pow(target - output, 2);
    }
    
    static squaredErrorLossPrime(target, output) {
        return -(target - output);  // dL/dOutput
    }
}

// --- MAIN APPLICATION ---
class BackpropVisualization {
    constructor() {
        this.container = document.getElementById('canvas-container');
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.mouseRaw = { x: 0, y: 0 };
        
        this.neurons = [];
        this.connections = [];
        this.layers = [2, 2, 1];
        this.labelElements = [];
        
        // State
        this.targetValue = 1.0;
        this.stepQueue = [];
        this.currentStepIndex = -1;
        this.isForwardComplete = false;
        this.isBackpropActive = false;
        this.isAnimating = false;
        this.autoPlayInterval = null;
        
        this.init();
    }

    init() {
        this.initThree();
        this.buildNetwork();
        this.initUI();
        this.updateNetworkValuesPanel();
        this.animate();
        
        window.addEventListener('resize', () => this.onWindowResize());
        window.addEventListener('mousemove', (e) => this.onMouseMove(e));
    }

    initThree() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(CONFIG.colors.background);
        this.scene.fog = new THREE.Fog(CONFIG.colors.background, 25, 80);

        // Camera
        this.camera = new THREE.PerspectiveCamera(
            45, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        this.camera.position.set(0, 5, 35);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 15;
        this.controls.maxDistance = 60;

        // Lighting
        this.scene.add(new THREE.AmbientLight(0x404040, 2));
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        this.scene.add(dirLight);
        
        const blueLight = new THREE.PointLight(0x4facfe, 0.6, 50);
        blueLight.position.set(-20, 10, 5);
        this.scene.add(blueLight);

        const redLight = new THREE.PointLight(0xff6b6b, 0.6, 50);
        redLight.position.set(20, 10, 5);
        this.scene.add(redLight);
    }

    buildNetwork() {
        this.clearNetwork();
        
        // Create neurons layer by layer
        let neuronId = 0;
        const startX = -((this.layers.length - 1) * CONFIG.dims.layerSpacing) / 2;
        const neuronNames = ['x₁', 'x₂', 'h₁', 'h₂', 'ŷ'];
        let nameIdx = 0;

        this.layers.forEach((neuronCount, layerIdx) => {
            const layerX = startX + (layerIdx * CONFIG.dims.layerSpacing);
            const startY = ((neuronCount - 1) * CONFIG.dims.neuronSpacing) / 2;

            for (let i = 0; i < neuronCount; i++) {
                const type = layerIdx === 0 ? 'input' 
                           : layerIdx === this.layers.length - 1 ? 'output' 
                           : 'hidden';
                
                const neuron = new Neuron(neuronId++, layerIdx, i, type);
                neuron.name = neuronNames[nameIdx++];
                neuron.position.set(layerX, startY - (i * CONFIG.dims.neuronSpacing), 0);
                
                // Set biases
                if (type === 'hidden') {
                    neuron.bias = CONFIG.network.biases.hidden[i];
                } else if (type === 'output') {
                    neuron.bias = CONFIG.network.biases.output;
                }
                
                // Create mesh
                const geometry = new THREE.SphereGeometry(CONFIG.dims.neuronSize, 32, 32);
                const material = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.neuron, 
                    roughness: 0.4, 
                    metalness: 0.6,
                    emissive: 0x000000 
                });
                neuron.mesh = new THREE.Mesh(geometry, material);
                neuron.mesh.position.copy(neuron.position);
                neuron.mesh.userData = { isNeuron: true, id: neuron.id };
                
                // Glow ring
                const ringGeo = new THREE.TorusGeometry(CONFIG.dims.neuronSize * 1.25, 0.06, 16, 50);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0x555566, 
                    transparent: true, 
                    opacity: 0.4 
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                neuron.mesh.add(ring);

                this.scene.add(neuron.mesh);
                this.neurons.push(neuron);
                this.createLabelsForNeuron(neuron);
            }
        });

        // Create connections with proper weight mapping
        // C2 notation: w1=x1->h1, w2=x2->h1, w3=x1->h2, w4=x2->h2, w5=h1->out, w6=h2->out
        const inputNeurons = this.neurons.filter(n => n.type === 'input');
        const hiddenNeurons = this.neurons.filter(n => n.type === 'hidden');
        const outputNeurons = this.neurons.filter(n => n.type === 'output');
        
        let weightIdx = 1;
        
        // Input -> Hidden connections
        // Following C2 order: w1(x1->h1), w2(x2->h1), w3(x1->h2), w4(x2->h2)
        hiddenNeurons.forEach((hidden, hIdx) => {
            inputNeurons.forEach((input, iIdx) => {
                const weight = CONFIG.network.weights.inputToHidden[iIdx][hIdx];
                const conn = new Connection(input, hidden, weight, `w${weightIdx++}`);
                input.connectionsOut.push(conn);
                hidden.connectionsIn.push(conn);
                this.connections.push(conn);
                this.createConnectionMesh(conn);
            });
        });
        
        // Hidden -> Output connections (w5, w6)
        hiddenNeurons.forEach((hidden, hIdx) => {
            const output = outputNeurons[0];
            const weight = CONFIG.network.weights.hiddenToOutput[hIdx];
            const conn = new Connection(hidden, output, weight, `w${weightIdx++}`);
            hidden.connectionsOut.push(conn);
            output.connectionsIn.push(conn);
            this.connections.push(conn);
            this.createConnectionMesh(conn);
        });

        // Set initial input values
        this.neurons[0].output = CONFIG.network.inputs[0];
        this.neurons[1].output = CONFIG.network.inputs[1];
        
        this.updateAllLabels();
    }

    createConnectionMesh(conn) {
        const curve = new THREE.LineCurve3(conn.source.position, conn.target.position);
        const tubeGeo = new THREE.TubeGeometry(curve, 1, 0.08, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ 
            color: CONFIG.colors.connection, 
            transparent: true, 
            opacity: 0.4 
        });
        conn.mesh = new THREE.Mesh(tubeGeo, tubeMat);
        this.scene.add(conn.mesh);
        
        // Weight label
        const midPoint = conn.source.position.clone().add(conn.target.position).multiplyScalar(0.5);
        const labelDiv = document.createElement('div');
        labelDiv.className = 'label weight';
        labelDiv.textContent = `${conn.weightName}=${conn.weight.toFixed(2)}`;
        document.body.appendChild(labelDiv);
        conn.labelElement = labelDiv;
        this.labelElements.push(labelDiv);
    }

    createLabelsForNeuron(neuron) {
        // Value label
        const valDiv = document.createElement('div');
        valDiv.className = 'label val';
        document.body.appendChild(valDiv);
        neuron.labelElement = valDiv;
        this.labelElements.push(valDiv);

        // Gradient label (hidden initially)
        const gradDiv = document.createElement('div');
        gradDiv.className = 'label grad';
        gradDiv.style.opacity = '0';
        document.body.appendChild(gradDiv);
        neuron.gradLabelElement = gradDiv;
        this.labelElements.push(gradDiv);
    }

    clearNetwork() {
        // Remove meshes
        this.neurons.forEach(n => {
            if (n.mesh) this.scene.remove(n.mesh);
        });
        this.connections.forEach(c => {
            if (c.mesh) this.scene.remove(c.mesh);
        });
        
        // Remove DOM labels
        this.labelElements.forEach(el => {
            if (el.parentNode) el.parentNode.removeChild(el);
        });
        
        this.neurons = [];
        this.connections = [];
        this.labelElements = [];
    }

    updateAllLabels() {
        this.neurons.forEach(neuron => {
            const screenPos = neuron.position.clone().project(this.camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;

            if (neuron.labelElement) {
                neuron.labelElement.style.left = `${x}px`;
                neuron.labelElement.style.top = `${y - 35}px`;
                
                if (neuron.type === 'input') {
                    neuron.labelElement.textContent = `${neuron.name}=${neuron.output.toFixed(2)}`;
                } else {
                    const biasStr = neuron.bias !== 0 ? ` (b=${neuron.bias})` : '';
                    neuron.labelElement.textContent = `${neuron.name}=${neuron.output.toFixed(4)}`;
                }
            }

            if (neuron.gradLabelElement) {
                neuron.gradLabelElement.style.left = `${x}px`;
                neuron.gradLabelElement.style.top = `${y + 35}px`;
            }
        });
        
        // Update connection labels
        this.connections.forEach(conn => {
            if (conn.labelElement) {
                const midPoint = conn.source.position.clone()
                    .add(conn.target.position).multiplyScalar(0.5);
                const screenPos = midPoint.project(this.camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
                
                conn.labelElement.style.left = `${x}px`;
                conn.labelElement.style.top = `${y}px`;
            }
        });
    }

    // --- FORWARD PASS ---
    runForwardPass() {
        this.resetVisuals();
        this.setStatus('Running forward pass...', '#4facfe');

        // Process hidden layer
        const hiddenNeurons = this.neurons.filter(n => n.type === 'hidden');
        hiddenNeurons.forEach((neuron, idx) => {
            let sum = neuron.bias;
            neuron.connectionsIn.forEach(conn => {
                sum += conn.source.output * conn.weight;
                this.animatePulse(conn, 'forward', idx * 200);
            });
            neuron.inputSum = sum;
            neuron.output = NeuralNetworkMath.sigmoid(sum);
            
            // Animate neuron
            setTimeout(() => {
                this.pulseNeuron(neuron, CONFIG.colors.neuronActive);
            }, 400 + idx * 200);
        });

        // Process output layer
        const outputNeuron = this.neurons.find(n => n.type === 'output');
        setTimeout(() => {
            let sum = outputNeuron.bias;
            outputNeuron.connectionsIn.forEach((conn, idx) => {
                sum += conn.source.output * conn.weight;
                this.animatePulse(conn, 'forward', idx * 100);
            });
            outputNeuron.inputSum = sum;
            outputNeuron.output = NeuralNetworkMath.sigmoid(sum);
            
            setTimeout(() => {
                this.pulseNeuron(outputNeuron, CONFIG.colors.neuronActive);
                this.updateAllLabels();
                this.updateNetworkValuesPanel();
                this.showForwardResult();
            }, 400);
        }, 800);
    }

    showForwardResult() {
        const output = this.neurons.find(n => n.type === 'output');
        const loss = NeuralNetworkMath.squaredErrorLoss(this.targetValue, output.output);
        
        this.isForwardComplete = true;
        
        // Show math panel with loss
        const panel = document.getElementById('math-panel');
        panel.classList.add('visible');
        
        document.getElementById('math-title').textContent = 'Forward Pass Complete';
        document.getElementById('math-eq').textContent = `Loss = ½(target - output)²`;
        document.getElementById('math-sub').textContent = 
            `= ½(${this.targetValue.toFixed(1)} - ${output.output.toFixed(4)})²`;
        document.getElementById('math-res').textContent = `Loss = ${loss.toFixed(6)}`;
        document.getElementById('math-desc').textContent = 
            `Output: ${output.output.toFixed(4)} | Target: ${this.targetValue} | Error: ${(this.targetValue - output.output).toFixed(4)}`;

        // Enable backprop
        document.getElementById('btn-start-back').disabled = false;
        this.setStatus('Forward pass complete! Click "Start Backprop" to compute gradients.', '#4cd964');
    }

    // --- BACKPROPAGATION ---
    prepareBackprop() {
        this.stepQueue = [];
        const target = this.targetValue;
        const outputNeuron = this.neurons.find(n => n.type === 'output');
        const hiddenNeurons = this.neurons.filter(n => n.type === 'hidden');
        const inputNeurons = this.neurons.filter(n => n.type === 'input');

        // === Step 1: Output Error ===
        const dL_dOut = NeuralNetworkMath.squaredErrorLossPrime(target, outputNeuron.output);
        const dOut_dZ = NeuralNetworkMath.sigmoidPrime(outputNeuron.inputSum);
        outputNeuron.delta = dL_dOut * dOut_dZ;

        this.stepQueue.push({
            type: 'output_delta',
            neuron: outputNeuron,
            title: 'Step 1: Output Error (δ₃)',
            eq: 'δ₃ = ∂L/∂ŷ × ∂ŷ/∂z₃',
            sub: `= (${outputNeuron.output.toFixed(4)} - ${target}) × σ'(${outputNeuron.inputSum.toFixed(4)})`,
            detail: `= ${dL_dOut.toFixed(4)} × ${dOut_dZ.toFixed(4)}`,
            res: `δ₃ = ${outputNeuron.delta.toFixed(6)}`,
            desc: 'How much does changing the pre-activation z₃ affect the loss?',
            highlightLocal: 'lg-loss'
        });

        // === Step 2: Output layer weight gradients ===
        outputNeuron.connectionsIn.forEach((conn, idx) => {
            conn.gradient = outputNeuron.delta * conn.source.output;
            
            this.stepQueue.push({
                type: 'weight_gradient',
                connection: conn,
                title: `Step 2${String.fromCharCode(97 + idx)}: Weight Gradient (${conn.weightName})`,
                eq: `∂L/∂${conn.weightName} = δ₃ × ${conn.source.name}`,
                sub: `= ${outputNeuron.delta.toFixed(6)} × ${conn.source.output.toFixed(4)}`,
                detail: '',
                res: `∂L/∂${conn.weightName} = ${conn.gradient.toFixed(6)}`,
                desc: `Gradient for ${conn.weightName}: how much this weight contributed to the error.`,
                highlightLocal: 'lg-multiply'
            });
        });

        // === Step 2c: Output bias gradient ===
        outputNeuron.biasGradient = outputNeuron.delta;
        this.stepQueue.push({
            type: 'bias_gradient',
            neuron: outputNeuron,
            title: 'Step 2c: Bias Gradient (b₃)',
            eq: '∂L/∂b₃ = δ₃ × 1',
            sub: `= ${outputNeuron.delta.toFixed(6)}`,
            detail: '',
            res: `∂L/∂b₃ = ${outputNeuron.biasGradient.toFixed(6)}`,
            desc: 'Bias gradient is simply the delta (since ∂z/∂b = 1).',
            highlightLocal: 'lg-add'
        });

        // === Step 3: Propagate to hidden layer ===
        hiddenNeurons.forEach((hNeuron, hIdx) => {
            // Error flowing back through the weight
            let errorSum = 0;
            hNeuron.connectionsOut.forEach(conn => {
                const contribution = conn.target.delta * conn.weight;
                errorSum += contribution;
                
                this.stepQueue.push({
                    type: 'error_flow',
                    connection: conn,
                    title: `Step 3: Error Flows Back to ${hNeuron.name}`,
                    eq: `Error from output = δ₃ × ${conn.weightName}`,
                    sub: `= ${conn.target.delta.toFixed(6)} × ${conn.weight.toFixed(2)}`,
                    detail: '',
                    res: `Contribution = ${contribution.toFixed(6)}`,
                    desc: `The output error flows backward through ${conn.weightName}.`,
                    highlightLocal: 'lg-multiply'
                });
            });

            // Hidden neuron delta
            const dH_dZ = NeuralNetworkMath.sigmoidPrime(hNeuron.inputSum);
            hNeuron.delta = errorSum * dH_dZ;

            this.stepQueue.push({
                type: 'hidden_delta',
                neuron: hNeuron,
                title: `Step 4: Hidden Delta (δ for ${hNeuron.name})`,
                eq: `δ_${hNeuron.name} = (Σ error_back) × σ'(z)`,
                sub: `= ${errorSum.toFixed(6)} × ${dH_dZ.toFixed(4)}`,
                detail: '',
                res: `δ_${hNeuron.name} = ${hNeuron.delta.toFixed(6)}`,
                desc: 'Accumulated error scaled by local activation derivative.',
                highlightLocal: 'lg-sigmoid'
            });

            // Hidden layer weight gradients
            hNeuron.connectionsIn.forEach((conn, cIdx) => {
                conn.gradient = hNeuron.delta * conn.source.output;
                
                this.stepQueue.push({
                    type: 'weight_gradient',
                    connection: conn,
                    title: `Step 5: Weight Gradient (${conn.weightName})`,
                    eq: `∂L/∂${conn.weightName} = δ_${hNeuron.name} × ${conn.source.name}`,
                    sub: `= ${hNeuron.delta.toFixed(6)} × ${conn.source.output.toFixed(2)}`,
                    detail: '',
                    res: `∂L/∂${conn.weightName} = ${conn.gradient.toFixed(6)}`,
                    desc: `Gradient for input weight ${conn.weightName}.`,
                    highlightLocal: 'lg-multiply'
                });
            });

            // Hidden bias gradient
            hNeuron.biasGradient = hNeuron.delta;
            this.stepQueue.push({
                type: 'bias_gradient',
                neuron: hNeuron,
                title: `Step 5: Bias Gradient (b for ${hNeuron.name})`,
                eq: `∂L/∂b_${hNeuron.name} = δ_${hNeuron.name}`,
                sub: `= ${hNeuron.delta.toFixed(6)}`,
                detail: '',
                res: `∂L/∂b = ${hNeuron.biasGradient.toFixed(6)}`,
                desc: 'Bias gradient equals the delta.',
                highlightLocal: 'lg-add'
            });
        });

        // === Final Summary ===
        this.stepQueue.push({
            type: 'summary',
            title: 'Backpropagation Complete!',
            eq: 'All ∂L/∂w Computed',
            sub: 'Ready for Gradient Descent',
            detail: '',
            res: `${this.connections.length} weight gradients + ${this.neurons.filter(n => n.type !== 'input').length} bias gradients`,
            desc: 'We now know exactly how to nudge each weight to reduce the loss.',
            highlightLocal: null
        });

        this.currentStepIndex = -1;
        this.isBackpropActive = true;
        
        // Show progress
        document.getElementById('progress-container').style.display = 'block';
        this.updateProgress();
        
        document.getElementById('btn-next').disabled = false;
        document.getElementById('btn-auto').disabled = false;
        document.getElementById('btn-start-back').disabled = true;
        
        this.setStatus('Backprop initialized. Step through to see gradient computation.', '#ff6b6b');
    }

    executeStep(direction) {
        if (this.isAnimating) return;
        
        if (direction === 'next' && this.currentStepIndex < this.stepQueue.length - 1) {
            this.currentStepIndex++;
        } else if (direction === 'prev' && this.currentStepIndex > 0) {
            this.currentStepIndex--;
        } else {
            return;
        }
        
        this.lockButtons();
        const step = this.stepQueue[this.currentStepIndex];
        this.renderStep(step);
        this.updateProgress();
        this.updateNetworkValuesPanel();
    }

    renderStep(step) {
        // Update math panel
        document.getElementById('math-title').textContent = step.title;
        document.getElementById('math-eq').textContent = step.eq;
        document.getElementById('math-sub').textContent = step.sub;
        if (step.detail) {
            document.getElementById('math-sub').textContent += '\n' + step.detail;
        }
        document.getElementById('math-res').textContent = step.res;
        document.getElementById('math-desc').textContent = step.desc;
        
        // Highlight local gradient
        document.querySelectorAll('.local-grad-item').forEach(el => el.classList.remove('active'));
        if (step.highlightLocal) {
            const el = document.getElementById(step.highlightLocal);
            if (el) el.classList.add('active');
        }

        // Visual effects based on step type
        switch (step.type) {
            case 'output_delta':
            case 'hidden_delta':
                this.pulseNeuron(step.neuron, CONFIG.colors.neuronBack);
                step.neuron.gradLabelElement.textContent = `δ=${step.neuron.delta.toFixed(4)}`;
                step.neuron.gradLabelElement.style.opacity = '1';
                break;
                
            case 'weight_gradient':
                this.pulseConnection(step.connection);
                this.animatePulse(step.connection, 'backward');
                // Update weight label to show gradient
                if (step.connection.labelElement) {
                    step.connection.labelElement.innerHTML = 
                        `${step.connection.weightName}=${step.connection.weight.toFixed(2)}<br>` +
                        `<span style="color:#ff6b6b">∇=${step.connection.gradient.toFixed(4)}</span>`;
                }
                break;
                
            case 'error_flow':
                this.animatePulse(step.connection, 'backward');
                this.pulseConnection(step.connection);
                break;
                
            case 'bias_gradient':
                this.pulseNeuron(step.neuron, CONFIG.colors.bias);
                break;
                
            case 'summary':
                // Flash all connections
                this.connections.forEach((conn, i) => {
                    setTimeout(() => this.pulseConnection(conn), i * 50);
                });
                break;
        }
    }

    lockButtons() {
        this.isAnimating = true;
        document.getElementById('btn-next').disabled = true;
        document.getElementById('btn-prev').disabled = true;
        
        setTimeout(() => {
            this.isAnimating = false;
            document.getElementById('btn-next').disabled = 
                this.currentStepIndex >= this.stepQueue.length - 1;
            document.getElementById('btn-prev').disabled = 
                this.currentStepIndex <= 0;
        }, CONFIG.animation.buttonLockTime);
    }

    updateProgress() {
        const total = this.stepQueue.length;
        const current = this.currentStepIndex + 1;
        const percent = total > 0 ? (current / total) * 100 : 0;
        
        document.getElementById('step-counter').textContent = `${current} / ${total}`;
        document.getElementById('progress-fill').style.width = `${percent}%`;
    }

    // --- ANIMATION HELPERS ---
    pulseNeuron(neuron, color) {
        if (!neuron || !neuron.mesh) return;
        
        const colorObj = new THREE.Color(color);
        new TWEEN.Tween(neuron.mesh.material.emissive)
            .to({ r: colorObj.r * 0.8, g: colorObj.g * 0.8, b: colorObj.b * 0.8 }, CONFIG.animation.pulseDuration)
            .easing(TWEEN.Easing.Quadratic.Out)
            .yoyo(true)
            .repeat(CONFIG.animation.pulseRepeats)
            .start();
    }

    pulseConnection(conn) {
        if (!conn || !conn.mesh) return;
        
        new TWEEN.Tween(conn.mesh.material)
            .to({ opacity: 1 }, CONFIG.animation.pulseDuration / 2)
            .easing(TWEEN.Easing.Quadratic.Out)
            .yoyo(true)
            .repeat(1)
            .start();
    }

    animatePulse(conn, direction, delay = 0) {
        setTimeout(() => {
            const geometry = new THREE.SphereGeometry(0.25, 12, 12);
            const color = direction === 'forward' 
                ? CONFIG.colors.signalForward 
                : CONFIG.colors.signalBackward;
            const material = new THREE.MeshBasicMaterial({ color });
            const particle = new THREE.Mesh(geometry, material);
            
            const startPos = direction === 'forward' 
                ? conn.source.position.clone() 
                : conn.target.position.clone();
            const endPos = direction === 'forward' 
                ? conn.target.position.clone() 
                : conn.source.position.clone();
            
            particle.position.copy(startPos);
            this.scene.add(particle);

            new TWEEN.Tween(particle.position)
                .to({ x: endPos.x, y: endPos.y, z: endPos.z }, CONFIG.animation.particleSpeed)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onComplete(() => {
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                })
                .start();
        }, delay);
    }

    // --- AUTO PLAY ---
    toggleAutoPlay() {
        if (this.autoPlayInterval) {
            clearInterval(this.autoPlayInterval);
            this.autoPlayInterval = null;
            document.getElementById('btn-auto').textContent = '▶ Auto Play';
        } else {
            document.getElementById('btn-auto').textContent = '⏸ Pause';
            this.autoPlayInterval = setInterval(() => {
                if (this.currentStepIndex >= this.stepQueue.length - 1) {
                    this.toggleAutoPlay();
                    return;
                }
                this.executeStep('next');
            }, CONFIG.animation.stepDelay);
        }
    }

    // --- RESET ---
    resetVisuals() {
        this.neurons.forEach(n => {
            if (n.mesh) n.mesh.material.emissive.setHex(0x000000);
            if (n.gradLabelElement) n.gradLabelElement.style.opacity = '0';
            n.delta = 0;
            n.biasGradient = 0;
        });
        
        this.connections.forEach(c => {
            if (c.mesh) {
                c.mesh.material.opacity = 0.4;
                c.mesh.material.color.setHex(CONFIG.colors.connection);
            }
            c.gradient = 0;
            if (c.labelElement) {
                c.labelElement.textContent = `${c.weightName}=${c.weight.toFixed(2)}`;
            }
        });
        
        document.querySelectorAll('.local-grad-item').forEach(el => el.classList.remove('active'));
        document.getElementById('math-panel').classList.remove('visible');
        document.getElementById('progress-container').style.display = 'none';
    }

    resetAll() {
        if (this.autoPlayInterval) {
            clearInterval(this.autoPlayInterval);
            this.autoPlayInterval = null;
        }
        
        this.resetVisuals();
        
        // Reset neuron values
        this.neurons.forEach(n => {
            if (n.type !== 'input') {
                n.output = 0;
                n.inputSum = 0;
            }
        });
        
        this.isForwardComplete = false;
        this.isBackpropActive = false;
        this.stepQueue = [];
        this.currentStepIndex = -1;
        
        document.getElementById('btn-start-back').disabled = true;
        document.getElementById('btn-next').disabled = true;
        document.getElementById('btn-prev').disabled = true;
        document.getElementById('btn-auto').disabled = true;
        document.getElementById('btn-auto').textContent = '▶ Auto Play';
        
        this.updateAllLabels();
        this.updateNetworkValuesPanel();
        this.setStatus('Reset complete. Ready to run forward pass.', '#888');
    }

    // --- UI HELPERS ---
    updateNetworkValuesPanel() {
        const content = document.getElementById('values-content');
        let html = '';
        
        // Weights
        this.connections.forEach(conn => {
            const gradStr = conn.gradient !== 0 
                ? `<span class="value-grad">${conn.gradient.toFixed(5)}</span>` 
                : '-';
            html += `<div class="value-row">
                <span class="value-label">${conn.weightName}</span>
                <span class="value-num">${conn.weight.toFixed(2)}</span>
                ${gradStr}
            </div>`;
        });
        
        // Biases
        this.neurons.filter(n => n.type !== 'input').forEach(n => {
            const name = n.type === 'output' ? 'b₃' : `b${n.indexInLayer + 1}`;
            const gradStr = n.biasGradient !== 0 
                ? `<span class="value-grad">${n.biasGradient.toFixed(5)}</span>` 
                : '-';
            html += `<div class="value-row">
                <span class="value-label">${name}</span>
                <span class="value-num">${n.bias.toFixed(2)}</span>
                ${gradStr}
            </div>`;
        });
        
        content.innerHTML = html;
    }

    setStatus(text, color = '#4facfe') {
        const el = document.getElementById('status-text');
        el.textContent = text;
        el.parentElement.style.borderLeftColor = color;
    }

    // --- EVENT HANDLERS ---
    initUI() {
        document.getElementById('target-slider').addEventListener('input', (e) => {
            this.targetValue = parseFloat(e.target.value);
            document.getElementById('target-val').textContent = this.targetValue.toFixed(1);
            
            if (this.isForwardComplete || this.isBackpropActive) {
                document.getElementById('btn-start-back').disabled = true;
                this.setStatus('Target changed. Run forward pass again.', '#ffcc00');
            }
        });

        document.getElementById('btn-forward').addEventListener('click', () => {
            this.resetAll();
            this.runForwardPass();
        });

        document.getElementById('btn-start-back').addEventListener('click', () => {
            this.prepareBackprop();
            this.executeStep('next');
        });

        document.getElementById('btn-next').addEventListener('click', () => {
            this.executeStep('next');
        });

        document.getElementById('btn-prev').addEventListener('click', () => {
            this.executeStep('prev');
        });

        document.getElementById('btn-auto').addEventListener('click', () => {
            this.toggleAutoPlay();
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            this.resetAll();
        });
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.updateAllLabels();
    }

    onMouseMove(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        this.mouseRaw.x = event.clientX;
        this.mouseRaw.y = event.clientY;
    }

    // --- ANIMATION LOOP ---
    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();
        
        // Tooltip on hover
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(
            this.neurons.map(n => n.mesh).filter(m => m), 
            false
        );
        
        const tooltip = document.getElementById('tooltip');
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData.isNeuron) {
                const neuron = this.neurons.find(n => n.id === obj.userData.id);
                if (neuron) {
                    tooltip.style.opacity = '1';
                    tooltip.style.left = (this.mouseRaw.x + 15) + 'px';
                    tooltip.style.top = (this.mouseRaw.y + 15) + 'px';
                    
                    let html = `<strong>${neuron.name} (${neuron.type})</strong>`;
                    if (neuron.type !== 'input') {
                        html += `
                            <div class="tt-row"><span class="tt-label">z (input sum):</span><span class="tt-val">${neuron.inputSum.toFixed(4)}</span></div>
                            <div class="tt-row"><span class="tt-label">a (output):</span><span class="tt-val">${neuron.output.toFixed(4)}</span></div>
                            <div class="tt-row"><span class="tt-label">bias:</span><span class="tt-val">${neuron.bias.toFixed(2)}</span></div>
                            <div class="tt-row"><span class="tt-label">δ (delta):</span><span class="tt-val">${neuron.delta.toFixed(6)}</span></div>
                        `;
                    } else {
                        html += `
                            <div class="tt-row"><span class="tt-label">value:</span><span class="tt-val">${neuron.output.toFixed(2)}</span></div>
                        `;
                    }
                    tooltip.innerHTML = html;
                }
            }
        } else {
            tooltip.style.opacity = '0';
        }

        this.controls.update();
        this.updateAllLabels();
        this.renderer.render(this.scene, this.camera);
    }
}

// Initialize
window.addEventListener('DOMContentLoaded', () => {
    new BackpropVisualization();
});
</script>
</body>
</html>

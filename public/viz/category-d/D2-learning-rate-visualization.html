<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D2: Learning Rate Effects - Interactive Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "../../lib/three/three.module.js",
                "three/addons/": "../../lib/three/examples/jsm/"
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0e1a;
            --bg-panel: rgba(15, 23, 42, 0.92);
            --accent-cyan: #22d3ee;
            --text-primary: #f1f5f9;
            --border-subtle: rgba(148, 163, 184, 0.15);
        }

        * { box-sizing: border-box; }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-deep);
            color: var(--text-primary); 
            font-family: 'Space Grotesk', sans-serif;
        }

        .mono { font-family: 'JetBrains Mono', monospace; }

        #canvas-container { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            z-index: 0; 
        }

        .glass-panel {
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-subtle);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-subtle); border-radius: 3px; }

        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 15px var(--accent-cyan);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, #34d399 0%, #34d399 15%, #38bdf8 30%, #38bdf8 45%, #fbbf24 60%, #fbbf24 75%, #f43f5e 90%, #f43f5e 100%);
            border-radius: 2px;
        }

        .status-badge {
            padding: 6px 16px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-slow {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
            border: 1px solid rgba(52, 211, 153, 0.3);
        }

        .status-good {
            background: rgba(56, 189, 248, 0.2);
            color: #38bdf8;
            border: 1px solid rgba(56, 189, 248, 0.3);
        }

        .status-oscillating {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .status-diverging {
            background: rgba(244, 63, 94, 0.2);
            color: #f43f5e;
            border: 1px solid rgba(244, 63, 94, 0.3);
            animation: pulse-warning 0.5s ease-in-out infinite;
        }

        .status-converged {
            background: rgba(52, 211, 153, 0.3);
            color: #34d399;
            border: 1px solid rgba(52, 211, 153, 0.5);
        }

        @keyframes pulse-warning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #loss-canvas {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
        }

        .preset-btn {
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            transform: translateY(-1px);
        }

        .param-section {
            border-left: 2px solid;
            padding-left: 10px;
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Left Panel - Controls -->
    <div class="absolute top-4 left-4 bottom-4 pointer-events-none flex flex-col" style="width: 300px;">
        <div class="glass-panel p-4 rounded-2xl pointer-events-auto flex-1 overflow-y-auto">
            <!-- Header -->
            <h1 class="text-xl font-bold mb-1">
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-400">Learning Rate</span>
                <span class="text-slate-400 text-base font-normal ml-2">Effects</span>
            </h1>
            <p class="text-xs text-slate-400 mb-4">
                See how learning rate affects gradient descent
            </p>
            
            <!-- Status Badge -->
            <div class="flex justify-center mb-4">
                <span id="status-badge" class="status-badge status-good">Converging Well</span>
            </div>

            <!-- Learning Rate Slider -->
            <div class="mb-5">
                <div class="flex justify-between items-center mb-2">
                    <label class="text-sm font-medium text-slate-300">Learning Rate (α)</label>
                    <span id="lr-value" class="mono text-lg text-cyan-400 font-bold">0.100</span>
                </div>
                <input type="range" id="lr-slider" min="0.001" max="2.5" step="0.001" value="0.1">
                <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                    <span>Too Small</span>
                    <span>Good</span>
                    <span>Oscillating</span>
                    <span>Diverging</span>
                </div>
            </div>

            <!-- Preset Buttons -->
            <div class="grid grid-cols-4 gap-1.5 mb-4">
                <button data-lr="0.01" class="preset-btn px-2 py-2 bg-green-900/30 hover:bg-green-800/40 rounded-lg text-[10px] font-medium border border-green-700/30 text-green-400">
                    Slow<br><span class="mono">0.01</span>
                </button>
                <button data-lr="0.15" class="preset-btn px-2 py-2 bg-cyan-900/30 hover:bg-cyan-800/40 rounded-lg text-[10px] font-medium border border-cyan-700/30 text-cyan-400">
                    Good<br><span class="mono">0.15</span>
                </button>
                <button data-lr="1.8" class="preset-btn px-2 py-2 bg-amber-900/30 hover:bg-amber-800/40 rounded-lg text-[10px] font-medium border border-amber-700/30 text-amber-400">
                    Oscillate<br><span class="mono">1.8</span>
                </button>
                <button data-lr="2.2" class="preset-btn px-2 py-2 bg-red-900/30 hover:bg-red-800/40 rounded-lg text-[10px] font-medium border border-red-700/30 text-red-400">
                    Diverge<br><span class="mono">2.2</span>
                </button>
            </div>

            <!-- Controls -->
            <div class="flex gap-2 mb-4">
                <button id="btn-reset" class="px-3 py-2 bg-slate-800 hover:bg-slate-700 rounded-lg text-xs font-medium transition border border-slate-700">
                    ↺ Reset
                </button>
                <button id="btn-step" class="px-3 py-2 bg-slate-800 hover:bg-slate-700 rounded-lg text-xs font-medium transition border border-slate-700">
                    ⏭ Step
                </button>
                <button id="btn-play" class="flex-1 px-3 py-2 bg-cyan-900/50 hover:bg-cyan-800/50 rounded-lg text-xs font-medium transition border border-cyan-700/50 text-cyan-300">
                    ▶ Play
                </button>
            </div>

            <!-- Speed Control -->
            <div class="mb-4">
                <div class="flex justify-between items-center mb-1">
                    <label class="text-xs font-medium text-slate-300">Animation Speed:</label>
                    <span id="speed-value" class="mono text-xs text-cyan-400">5</span>
                </div>
                <input type="range" id="speed-slider" min="1" max="20" step="1" value="5" style="background: transparent;">
            </div>

            <!-- Divider -->
            <div class="border-t border-slate-700/50 my-4"></div>

            <!-- Current State -->
            <h3 class="text-xs font-semibold text-slate-400 mb-3 uppercase tracking-wider">Current State</h3>
            <div class="grid grid-cols-2 gap-2 mb-4">
                <div class="bg-slate-800/50 rounded-lg p-2.5">
                    <div class="text-[10px] text-slate-500 mb-1">Position</div>
                    <div class="mono text-xs">
                        (<span id="pos-x" class="text-cyan-400">0.00</span>, <span id="pos-y" class="text-cyan-400">0.00</span>)
                    </div>
                </div>
                <div class="bg-slate-800/50 rounded-lg p-2.5">
                    <div class="text-[10px] text-slate-500 mb-1">Loss</div>
                    <div class="mono text-xs text-amber-400" id="current-loss">0.0000</div>
                </div>
                <div class="bg-slate-800/50 rounded-lg p-2.5">
                    <div class="text-[10px] text-slate-500 mb-1">Step Size</div>
                    <div class="mono text-xs text-green-400" id="step-size">0.0000</div>
                </div>
                <div class="bg-slate-800/50 rounded-lg p-2.5">
                    <div class="text-[10px] text-slate-500 mb-1">Iteration</div>
                    <div class="mono text-xs text-slate-300" id="iteration">0</div>
                </div>
            </div>

            <!-- Gradient Info -->
            <div class="bg-slate-800/50 rounded-lg p-2.5 mb-4">
                <div class="text-[10px] text-slate-500 mb-1">Gradient ∇L</div>
                <div class="mono text-xs">
                    (<span id="grad-x" class="text-green-400">0.00</span>, <span id="grad-y" class="text-green-400">0.00</span>)
                    <span class="text-slate-500 ml-2">|∇L| = </span><span id="grad-mag" class="text-green-400">0.00</span>
                </div>
            </div>

            <!-- Divider -->
            <div class="border-t border-slate-700/50 my-4"></div>

            <!-- Convergence Analysis -->
            <h3 class="text-xs font-semibold text-slate-400 mb-3 uppercase tracking-wider">Convergence Factor</h3>
            <div class="bg-slate-800/50 rounded-lg p-3 mb-4">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-[10px] text-slate-500">|1 - α| =</span>
                    <span id="convergence-factor" class="mono text-sm font-bold">0.90</span>
                </div>
                <div class="h-2 bg-slate-700 rounded-full overflow-hidden">
                    <div id="convergence-bar" class="h-full bg-cyan-500 transition-all duration-300" style="width: 45%"></div>
                </div>
                <div class="flex justify-between text-[9px] text-slate-500 mt-1">
                    <span>0 (instant)</span>
                    <span>1 (boundary)</span>
                    <span>2+ (diverge)</span>
                </div>
                <p id="convergence-explanation" class="text-[10px] text-slate-400 mt-2">
                    Values < 1 converge. Values > 1 diverge.
                </p>
            </div>
        </div>
    </div>

    <!-- Right Panel - Loss Chart & Explanation -->
    <div class="absolute top-4 right-4 bottom-4 pointer-events-none flex flex-col" style="width: 340px;">
        <div class="glass-panel p-4 rounded-2xl pointer-events-auto flex-1 overflow-y-auto">
            <!-- Loss Chart -->
            <div class="flex items-center justify-between mb-3">
                <h2 class="text-xs font-bold text-slate-500 uppercase tracking-wider">Loss Over Time</h2>
                <span id="loss-trend" class="text-[10px] px-2 py-0.5 rounded bg-slate-800 text-slate-400">—</span>
            </div>
            <canvas id="loss-canvas" width="300" height="140"></canvas>
            <div class="flex justify-between mt-2 text-[9px] text-slate-500 mono">
                <span>Step 0</span>
                <span id="max-iter-label">Step 100</span>
            </div>

            <!-- Divider -->
            <div class="border-t border-slate-700/50 my-4"></div>

            <!-- Explanation Panel -->
            <h3 class="text-xs font-semibold text-slate-400 mb-2 uppercase tracking-wider">What's Happening</h3>
            <p id="explanation" class="text-xs text-slate-300 leading-relaxed mb-4">
                The learning rate controls how big each step is. A good learning rate finds the balance between speed and stability.
            </p>

            <!-- Math Insight -->
            <div class="bg-slate-800/50 rounded-lg p-3">
                <div class="text-[10px] text-slate-500 mb-2">For this quadratic bowl:</div>
                <div class="mono text-xs text-center mb-2">
                    <span class="text-cyan-400">x</span><sub class="text-slate-500">new</sub>
                    <span class="text-slate-400"> = </span>
                    <span class="text-cyan-400">x</span>
                    <span class="text-slate-400">(1 - </span>
                    <span class="text-amber-400">α</span>
                    <span class="text-slate-400">)</span>
                </div>
                <p id="math-insight" class="text-[10px] text-slate-400">
                    Each step multiplies position by (1 - α). This factor determines whether you converge or diverge.
                </p>
            </div>

            <!-- Divider -->
            <div class="border-t border-slate-700/50 my-4"></div>

            <!-- Key Thresholds -->
            <h3 class="text-xs font-semibold text-slate-400 mb-2 uppercase tracking-wider">Key Thresholds</h3>
            <div class="space-y-2 text-[11px]">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-green-500"></div>
                    <span class="text-slate-400">α < 0.1:</span>
                    <span class="text-slate-300">Slow but stable convergence</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-cyan-500"></div>
                    <span class="text-slate-400">α ≈ 0.1-1.0:</span>
                    <span class="text-slate-300">Good convergence rate</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-amber-500"></div>
                    <span class="text-slate-400">α ≈ 1.0-2.0:</span>
                    <span class="text-slate-300">Oscillating but converging</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-red-500"></div>
                    <span class="text-slate-400">α > 2.0:</span>
                    <span class="text-slate-300">Diverging! Loss increases</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Formula - Bottom Center -->
    <div class="absolute bottom-4 pointer-events-none" style="left: 320px; right: 360px;">
        <div class="glass-panel px-6 py-3 rounded-2xl pointer-events-auto mx-auto w-fit">
            <div class="mono text-sm text-center">
                <span class="text-slate-500">Update Rule:</span>
                <span class="text-cyan-400 ml-2">θ</span>
                <span class="text-slate-400"> ← </span>
                <span class="text-cyan-400">θ</span>
                <span class="text-slate-400"> − </span>
                <span class="text-amber-400">α</span>
                <span class="text-slate-400"> × </span>
                <span class="text-green-400">∇L(θ)</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ═══════════════════════════════════════════════════════════════
        // CONFIGURATION
        // ═══════════════════════════════════════════════════════════════

        const CONFIG = {
            surface: {
                size: 8,
                resolution: 80
            },
            startPosition: { x: 3, y: 3 },
            trail: {
                maxPoints: 500
            },
            animation: {
                baseInterval: 200  // ms at speed 1
            },
            convergence: {
                lossThreshold: 0.0001,
                divergenceThreshold: 1000
            }
        };

        // Simple quadratic bowl: L(x,y) = 0.5(x² + y²)
        // Gradient: ∇L = (x, y)
        // For this function, the update x_new = x - α*x = x(1-α)
        // Converges if |1-α| < 1, i.e., 0 < α < 2
        // Diverges if |1-α| > 1, i.e., α > 2 or α < 0
        const lossFunc = (x, y) => 0.5 * (x * x + y * y);
        const gradX = (x, y) => x;
        const gradY = (x, y) => y;

        // ═══════════════════════════════════════════════════════════════
        // STATE
        // ═══════════════════════════════════════════════════════════════

        const state = {
            x: CONFIG.startPosition.x,
            y: CONFIG.startPosition.y,
            learningRate: 0.1,
            speed: 5,
            isPlaying: false,
            iteration: 0,
            lossHistory: [lossFunc(CONFIG.startPosition.x, CONFIG.startPosition.y)],
            pathIndex: 0
        };

        // ═══════════════════════════════════════════════════════════════
        // THREE.JS SETUP
        // ═══════════════════════════════════════════════════════════════

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 14, 0.1);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5;
        controls.maxDistance = 30;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // ═══════════════════════════════════════════════════════════════
        // CREATE CONTOUR SURFACE
        // ═══════════════════════════════════════════════════════════════

        const contourGroup = new THREE.Group();
        scene.add(contourGroup);

        function createContourSurface() {
            while (contourGroup.children.length) {
                const child = contourGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                contourGroup.remove(child);
            }

            // Base plane with gradient coloring
            const planeSize = CONFIG.surface.size * 2;
            const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize, 50, 50);
            const positions = planeGeo.attributes.position.array;
            const colors = new Float32Array(positions.length);

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const loss = lossFunc(x, y);
                const t = Math.min(1, loss / 32);
                
                // Color based on loss value
                const color = new THREE.Color();
                color.setHSL(0.6 - t * 0.5, 0.5, 0.15 + t * 0.1);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }

            planeGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const planeMat = new THREE.MeshPhongMaterial({ 
                vertexColors: true,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.02;
            contourGroup.add(plane);

            // Contour lines (circles for quadratic bowl)
            const contourLevels = [0.5, 1, 2, 4, 8, 12, 16, 24, 32];
            
            contourLevels.forEach((level, idx) => {
                const radius = Math.sqrt(2 * level);
                if (radius > CONFIG.surface.size) return;

                const segments = 64;
                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }

                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const hue = 0.55 - (idx / contourLevels.length) * 0.4;
                const mat = new THREE.LineBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                    transparent: true,
                    opacity: 0.7
                });
                const line = new THREE.Line(geo, mat);
                contourGroup.add(line);
            });

            // Grid
            const gridHelper = new THREE.GridHelper(planeSize, 20, 0x1e3a5f, 0x1e293b);
            gridHelper.position.y = 0.01;
            contourGroup.add(gridHelper);

            // Optimal point marker (center)
            const optimalGeo = new THREE.RingGeometry(0.12, 0.2, 32);
            const optimalMat = new THREE.MeshBasicMaterial({ color: 0x34d399, side: THREE.DoubleSide });
            const optimal = new THREE.Mesh(optimalGeo, optimalMat);
            optimal.rotation.x = -Math.PI / 2;
            optimal.position.y = 0.02;
            contourGroup.add(optimal);

            // Center dot
            const centerDot = new THREE.Mesh(
                new THREE.CircleGeometry(0.08, 16),
                new THREE.MeshBasicMaterial({ color: 0x34d399 })
            );
            centerDot.rotation.x = -Math.PI / 2;
            centerDot.position.y = 0.03;
            contourGroup.add(centerDot);
        }

        // ═══════════════════════════════════════════════════════════════
        // OPTIMIZER VISUALIZATION
        // ═══════════════════════════════════════════════════════════════

        let positionMarker, trailLine, gradientArrow;
        let trailPositions;

        function createOptimizerVisuals() {
            // Current position ball
            const ballGeo = new THREE.SphereGeometry(0.18, 32, 32);
            const ballMat = new THREE.MeshPhongMaterial({
                color: 0x38bdf8,
                emissive: 0x38bdf8,
                emissiveIntensity: 0.5
            });
            positionMarker = new THREE.Mesh(ballGeo, ballMat);
            positionMarker.position.set(state.x, 0.18, state.y);
            scene.add(positionMarker);

            // Pre-allocated trail
            trailPositions = new Float32Array(CONFIG.trail.maxPoints * 3);
            const trailGeo = new THREE.BufferGeometry();
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeo.setDrawRange(0, 1);
            
            // Set initial point
            trailPositions[0] = state.x;
            trailPositions[1] = 0.05;
            trailPositions[2] = state.y;

            const trailMat = new THREE.LineBasicMaterial({ 
                color: 0x38bdf8,
                transparent: true,
                opacity: 0.8
            });
            trailLine = new THREE.Line(trailGeo, trailMat);
            scene.add(trailLine);

            // Gradient arrow
            const arrowDir = new THREE.Vector3(1, 0, 0);
            const arrowOrigin = new THREE.Vector3(0, 0.3, 0);
            gradientArrow = new THREE.ArrowHelper(arrowDir, arrowOrigin, 1, 0x34d399, 0.15, 0.08);
            gradientArrow.visible = false;
            scene.add(gradientArrow);
        }

        function updateOptimizerVisuals() {
            // Clamp display position for very diverged states
            const displayX = Math.max(-15, Math.min(15, state.x));
            const displayY = Math.max(-15, Math.min(15, state.y));
            
            positionMarker.position.x = displayX;
            positionMarker.position.z = displayY;

            // Update trail
            if (state.pathIndex < CONFIG.trail.maxPoints) {
                const idx = state.pathIndex * 3;
                trailPositions[idx] = displayX;
                trailPositions[idx + 1] = 0.05;
                trailPositions[idx + 2] = displayY;
                trailLine.geometry.attributes.position.needsUpdate = true;
                trailLine.geometry.setDrawRange(0, state.pathIndex + 1);
            }

            // Update gradient arrow
            const gx = gradX(state.x, state.y);
            const gy = gradY(state.y, state.y);
            const gradMag = Math.sqrt(gx * gx + gy * gy);
            
            if (gradMag > 0.01 && gradMag < 100) {
                gradientArrow.visible = true;
                gradientArrow.position.set(displayX, 0.3, displayY);
                const dir = new THREE.Vector3(-gx / gradMag, 0, -gy / gradMag);
                gradientArrow.setDirection(dir);
                gradientArrow.setLength(Math.min(gradMag * state.learningRate, 3), 0.15, 0.08);
            } else {
                gradientArrow.visible = false;
            }

            // Color based on status
            const status = getStatus();
            let color;
            switch (status) {
                case 'slow': color = 0x34d399; break;
                case 'good': color = 0x38bdf8; break;
                case 'oscillating': color = 0xfbbf24; break;
                case 'diverging': color = 0xf43f5e; break;
                case 'converged': color = 0x34d399; break;
                default: color = 0x38bdf8;
            }
            positionMarker.material.color.setHex(color);
            positionMarker.material.emissive.setHex(color);
            trailLine.material.color.setHex(color);
        }

        // ═══════════════════════════════════════════════════════════════
        // GRADIENT DESCENT STEP
        // ═══════════════════════════════════════════════════════════════

        function step() {
            const gx = gradX(state.x, state.y);
            const gy = gradY(state.x, state.y);

            state.x -= state.learningRate * gx;
            state.y -= state.learningRate * gy;

            state.pathIndex++;

            const loss = lossFunc(state.x, state.y);
            state.lossHistory.push(loss);
            if (state.lossHistory.length > 200) {
                state.lossHistory.shift();
            }

            state.iteration++;
            
            updateUI();
            updateOptimizerVisuals();
            drawLossChart();
        }

        function reset() {
            state.x = CONFIG.startPosition.x;
            state.y = CONFIG.startPosition.y;
            state.iteration = 0;
            state.pathIndex = 0;
            state.lossHistory = [lossFunc(CONFIG.startPosition.x, CONFIG.startPosition.y)];
            state.isPlaying = false;
            document.getElementById('btn-play').textContent = '▶ Play';

            // Reset trail
            trailPositions.fill(0);
            trailPositions[0] = state.x;
            trailPositions[1] = 0.05;
            trailPositions[2] = state.y;
            trailLine.geometry.attributes.position.needsUpdate = true;
            trailLine.geometry.setDrawRange(0, 1);

            updateUI();
            updateOptimizerVisuals();
            drawLossChart();
        }

        // ═══════════════════════════════════════════════════════════════
        // STATUS DETECTION (CORRECTED)
        // ═══════════════════════════════════════════════════════════════

        function getStatus() {
            const loss = lossFunc(state.x, state.y);
            const alpha = state.learningRate;
            const convergenceFactor = Math.abs(1 - alpha);

            // Converged: loss very small
            if (loss < CONFIG.convergence.lossThreshold) {
                return 'converged';
            }

            // Diverging: based on the math |1-α| > 1, or loss exploding
            if (convergenceFactor > 1 || loss > CONFIG.convergence.divergenceThreshold) {
                return 'diverging';
            }

            // Check for oscillation: |1-α| close to 1 means slow damping, and sign flip
            if (alpha > 1 && alpha < 2) {
                return 'oscillating';
            }

            // Slow: very small learning rate
            if (alpha < 0.05) {
                return 'slow';
            }

            return 'good';
        }

        function getConvergenceFactor() {
            return Math.abs(1 - state.learningRate);
        }

        // ═══════════════════════════════════════════════════════════════
        // UI UPDATES
        // ═══════════════════════════════════════════════════════════════

        function updateUI() {
            const loss = lossFunc(state.x, state.y);
            const gx = gradX(state.x, state.y);
            const gy = gradY(state.x, state.y);
            const gradMag = Math.sqrt(gx * gx + gy * gy);
            const stepSize = state.learningRate * gradMag;
            const convergenceFactor = getConvergenceFactor();

            // Position and loss
            document.getElementById('pos-x').textContent = state.x.toFixed(3);
            document.getElementById('pos-y').textContent = state.y.toFixed(3);
            document.getElementById('current-loss').textContent = loss > 1000 ? loss.toExponential(2) : loss.toFixed(4);
            document.getElementById('step-size').textContent = stepSize > 100 ? stepSize.toExponential(2) : stepSize.toFixed(4);
            document.getElementById('iteration').textContent = state.iteration;

            // Gradient
            document.getElementById('grad-x').textContent = gx.toFixed(3);
            document.getElementById('grad-y').textContent = gy.toFixed(3);
            document.getElementById('grad-mag').textContent = gradMag.toFixed(3);

            // Convergence factor visualization
            const cfDisplay = document.getElementById('convergence-factor');
            cfDisplay.textContent = convergenceFactor.toFixed(3);
            
            if (convergenceFactor < 1) {
                cfDisplay.className = 'mono text-sm font-bold text-green-400';
            } else {
                cfDisplay.className = 'mono text-sm font-bold text-red-400';
            }

            const barWidth = Math.min(100, (convergenceFactor / 2) * 100);
            const bar = document.getElementById('convergence-bar');
            bar.style.width = barWidth + '%';
            
            if (convergenceFactor < 0.5) {
                bar.className = 'h-full bg-green-500 transition-all duration-300';
            } else if (convergenceFactor < 1) {
                bar.className = 'h-full bg-cyan-500 transition-all duration-300';
            } else if (convergenceFactor < 1.5) {
                bar.className = 'h-full bg-amber-500 transition-all duration-300';
            } else {
                bar.className = 'h-full bg-red-500 transition-all duration-300';
            }

            // Convergence explanation
            const cfExplanation = document.getElementById('convergence-explanation');
            if (convergenceFactor < 0.5) {
                cfExplanation.textContent = 'Strong convergence: position shrinks by ' + ((1 - convergenceFactor) * 100).toFixed(0) + '% each step.';
            } else if (convergenceFactor < 1) {
                cfExplanation.textContent = 'Converging: each step reduces position by ' + ((1 - convergenceFactor) * 100).toFixed(0) + '%.';
            } else {
                cfExplanation.textContent = 'DIVERGING: each step INCREASES position by ' + ((convergenceFactor - 1) * 100).toFixed(0) + '%!';
            }

            // Update status badge
            const status = getStatus();
            const badge = document.getElementById('status-badge');
            badge.className = 'status-badge';
            
            const explanations = {
                slow: {
                    class: 'status-slow',
                    text: 'Converging Slowly',
                    explanation: 'With a very small learning rate, each step is tiny. The optimizer will eventually reach the minimum, but it takes many iterations. This can be impractical for large models.',
                    math: 'Factor ' + convergenceFactor.toFixed(2) + ' is small, so convergence is guaranteed but slow.'
                },
                good: {
                    class: 'status-good',
                    text: 'Converging Well',
                    explanation: 'This learning rate strikes a good balance. Steps are large enough for quick progress but small enough to stay stable. The loss decreases smoothly toward the minimum.',
                    math: 'Factor ' + convergenceFactor.toFixed(2) + ' < 1 ensures convergence with good speed.'
                },
                oscillating: {
                    class: 'status-oscillating',
                    text: 'Oscillating',
                    explanation: 'The learning rate is between 1 and 2, so |1-α| is still < 1. The optimizer oscillates (overshoots and bounces back) but still converges because each overshoot is smaller than the last.',
                    math: 'Factor ' + convergenceFactor.toFixed(2) + ' < 1, so oscillations dampen. Position flips sign each step.'
                },
                diverging: {
                    class: 'status-diverging',
                    text: '⚠ DIVERGING',
                    explanation: 'The learning rate exceeds 2, making |1-α| > 1. Each step overshoots MORE than the previous one. The loss explodes toward infinity!',
                    math: 'Factor ' + convergenceFactor.toFixed(2) + ' > 1 means each step AMPLIFIES the error!'
                },
                converged: {
                    class: 'status-converged',
                    text: '✓ Converged',
                    explanation: 'The optimizer has reached the minimum! The loss is essentially zero and the position is at the optimal point (0, 0).',
                    math: 'Loss < ' + CONFIG.convergence.lossThreshold + ', optimization complete.'
                }
            };

            const info = explanations[status];
            badge.classList.add(info.class);
            badge.textContent = info.text;
            document.getElementById('explanation').textContent = info.explanation;
            document.getElementById('math-insight').textContent = info.math;

            // Loss trend
            const trend = document.getElementById('loss-trend');
            if (state.lossHistory.length > 5) {
                const recent = state.lossHistory.slice(-3);
                const older = state.lossHistory.slice(-6, -3);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                
                if (recentAvg < olderAvg * 0.9) {
                    trend.textContent = '↓ Decreasing';
                    trend.className = 'text-[10px] px-2 py-0.5 rounded bg-green-900/50 text-green-400';
                } else if (recentAvg > olderAvg * 1.1) {
                    trend.textContent = '↑ Increasing';
                    trend.className = 'text-[10px] px-2 py-0.5 rounded bg-red-900/50 text-red-400';
                } else {
                    trend.textContent = '→ Stable';
                    trend.className = 'text-[10px] px-2 py-0.5 rounded bg-slate-800 text-slate-400';
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // LOSS CHART
        // ═══════════════════════════════════════════════════════════════

        const lossCanvas = document.getElementById('loss-canvas');
        const ctx = lossCanvas.getContext('2d');

        function drawLossChart() {
            const width = lossCanvas.width;
            const height = lossCanvas.height;
            
            ctx.clearRect(0, 0, width, height);

            if (state.lossHistory.length < 2) return;

            // Use log scale for better visualization of divergence
            const logLosses = state.lossHistory.map(l => Math.log10(Math.max(0.0001, l)));
            const maxLog = Math.max(...logLosses, 2);
            const minLog = Math.min(...logLosses, -4);
            const range = maxLog - minLog;

            // Draw grid
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (height / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw zero line (log10(1) = 0)
            if (minLog < 0 && maxLog > 0) {
                const zeroY = height - ((0 - minLog) / range) * height;
                ctx.strokeStyle = 'rgba(52, 211, 153, 0.3)';
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(width, zeroY);
                ctx.stroke();
            }

            // Draw loss curve
            ctx.beginPath();
            const status = getStatus();
            let strokeColor = '#38bdf8';
            if (status === 'diverging') strokeColor = '#f43f5e';
            else if (status === 'oscillating') strokeColor = '#fbbf24';
            else if (status === 'slow') strokeColor = '#34d399';
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;

            logLosses.forEach((logLoss, i) => {
                const x = (i / (logLosses.length - 1)) * width;
                const y = height - ((logLoss - minLog) / range) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, Math.max(0, Math.min(height, y)));
                } else {
                    ctx.lineTo(x, Math.max(0, Math.min(height, y)));
                }
            });
            ctx.stroke();

            // Draw current point
            const lastLogLoss = logLosses[logLosses.length - 1];
            const lastY = height - ((lastLogLoss - minLog) / range) * height;
            ctx.beginPath();
            ctx.arc(width - 5, Math.max(5, Math.min(height - 5, lastY)), 4, 0, Math.PI * 2);
            ctx.fillStyle = strokeColor;
            ctx.fill();

            document.getElementById('max-iter-label').textContent = `Step ${state.iteration}`;
        }

        // ═══════════════════════════════════════════════════════════════
        // EVENT HANDLERS
        // ═══════════════════════════════════════════════════════════════

        document.getElementById('lr-slider').addEventListener('input', (e) => {
            state.learningRate = parseFloat(e.target.value);
            document.getElementById('lr-value').textContent = state.learningRate.toFixed(3);
            updateUI(); // Update convergence factor display immediately
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            state.speed = parseInt(e.target.value);
            document.getElementById('speed-value').textContent = state.speed;
        });

        document.querySelectorAll('[data-lr]').forEach(btn => {
            btn.addEventListener('click', () => {
                const lr = parseFloat(btn.dataset.lr);
                state.learningRate = lr;
                document.getElementById('lr-slider').value = lr;
                document.getElementById('lr-value').textContent = lr.toFixed(3);
                reset();
            });
        });

        document.getElementById('btn-reset').addEventListener('click', reset);

        document.getElementById('btn-step').addEventListener('click', () => {
            const status = getStatus();
            if (status !== 'converged') {
                step();
            }
        });

        document.getElementById('btn-play').addEventListener('click', () => {
            state.isPlaying = !state.isPlaying;
            document.getElementById('btn-play').textContent = state.isPlaying ? '⏸ Pause' : '▶ Play';
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ═══════════════════════════════════════════════════════════════
        // ANIMATION LOOP
        // ═══════════════════════════════════════════════════════════════

        let lastStepTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);

            const stepInterval = Math.max(20, CONFIG.animation.baseInterval - state.speed * 9);

            if (state.isPlaying && time - lastStepTime > stepInterval) {
                const status = getStatus();
                
                // Stop if converged
                if (status === 'converged') {
                    state.isPlaying = false;
                    document.getElementById('btn-play').textContent = '▶ Play';
                }
                // Stop divergence after it's clearly demonstrated
                else if (status === 'diverging' && state.iteration > 20) {
                    state.isPlaying = false;
                    document.getElementById('btn-play').textContent = '▶ Play';
                }
                else {
                    step();
                }
                
                lastStepTime = time;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ═══════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════

        createContourSurface();
        createOptimizerVisuals();
        updateUI();
        updateOptimizerVisuals();
        drawLossChart();
        animate(0);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Learning Rate Explorer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --slate-900: #0f172a;
      --slate-800: #1e293b;
      --slate-700: #334155;
      --slate-600: #475569;
      --slate-500: #64748b;
      --slate-400: #94a3b8;
      --slate-300: #cbd5e1;
      --slate-100: #f1f5f9;
      --blue-500: #3b82f6;
      --blue-400: #60a5fa;
      --green-500: #22c55e;
      --green-400: #4ade80;
      --emerald-500: #10b981;
      --emerald-400: #34d399;
      --amber-500: #f59e0b;
      --amber-400: #fbbf24;
      --red-500: #ef4444;
      --red-400: #f87171;
      --indigo-600: #4f46e5;
      --indigo-500: #6366f1;
      --cyan-400: #22d3ee;
      --yellow-400: #facc15;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--slate-900);
      color: var(--slate-100);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* Header */
    .header {
      height: 64px;
      border-bottom: 1px solid var(--slate-700);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 1.5rem;
      background: var(--slate-900);
      z-index: 10;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .header-icon {
      padding: 0.5rem;
      background: var(--indigo-600);
      border-radius: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header h1 {
      font-weight: 700;
      font-size: 1.125rem;
      line-height: 1.2;
    }

    .header p {
      font-size: 0.75rem;
      color: var(--slate-400);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .iteration-badge {
      background: var(--slate-800);
      padding: 0.375rem 1rem;
      border-radius: 9999px;
      border: 1px solid var(--slate-700);
      font-size: 0.875rem;
      font-family: 'JetBrains Mono', monospace;
      color: var(--cyan-400);
    }

    /* Status Badge */
    .status-badge {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.375rem 0.75rem;
      border-radius: 9999px;
      border: 1px solid;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .status-badge.converging {
      background: rgba(16, 185, 129, 0.1);
      color: var(--emerald-400);
      border-color: rgba(16, 185, 129, 0.3);
    }

    .status-badge.oscillating {
      background: rgba(251, 191, 36, 0.1);
      color: var(--amber-400);
      border-color: rgba(251, 191, 36, 0.3);
    }

    .status-badge.diverging {
      background: rgba(239, 68, 68, 0.1);
      color: var(--red-400);
      border-color: rgba(239, 68, 68, 0.3);
    }

    .status-badge.converged {
      background: rgba(96, 165, 250, 0.1);
      color: var(--blue-400);
      border-color: rgba(96, 165, 250, 0.3);
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      position: relative;
      overflow: hidden;
    }

    /* Canvas Area */
    .canvas-container {
      flex: 1;
      position: relative;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Stats Overlay */
    .stats-overlay {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(8px);
      padding: 1rem;
      border-radius: 0.75rem;
      border: 1px solid var(--slate-700);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      user-select: none;
      min-width: 260px;
    }

    .stats-overlay h3 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--slate-300);
      margin-bottom: 0.75rem;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      margin-bottom: 0.375rem;
    }

    .stat-row .label {
      color: var(--slate-400);
    }

    .stat-row .value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--slate-200);
    }

    .chart-section {
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--slate-700);
    }

    .chart-section .label {
      font-size: 0.75rem;
      color: var(--slate-500);
      margin-bottom: 0.5rem;
    }

    #lossChart {
      width: 100%;
      height: 64px;
      background: rgba(30, 41, 59, 0.5);
      border-radius: 0.25rem;
      border: 1px solid rgba(51, 65, 85, 0.5);
    }

    /* Legend */
    .legend {
      position: absolute;
      top: 1rem;
      right: 340px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(8px);
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid var(--slate-700);
      pointer-events: none;
      user-select: none;
    }

    .legend h4 {
      font-size: 0.625rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--slate-400);
      margin-bottom: 0.5rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      margin-bottom: 0.25rem;
    }

    .legend-item:last-child {
      margin-bottom: 0;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-item .lr {
      font-family: 'JetBrains Mono', monospace;
      color: var(--slate-400);
      font-size: 0.625rem;
    }

    /* Intro Overlay */
    .intro-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 5;
    }

    .intro-card {
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      padding: 2rem;
      border-radius: 1rem;
      border: 1px solid var(--slate-600);
      text-align: center;
      max-width: 28rem;
    }

    .intro-card h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .intro-card p {
      color: var(--slate-300);
      margin-bottom: 1rem;
    }

    .intro-card .tip {
      font-size: 0.875rem;
      color: var(--indigo-400);
    }

    .intro-card.hidden {
      display: none;
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: var(--slate-900);
      border-left: 1px solid var(--slate-700);
      display: flex;
      flex-direction: column;
      z-index: 20;
      box-shadow: -4px 0 15px rgba(0, 0, 0, 0.2);
    }

    .sidebar-content {
      padding: 1.5rem;
      overflow-y: auto;
      flex: 1;
    }

    .sidebar-section {
      margin-bottom: 2rem;
    }

    .sidebar-section:last-child {
      margin-bottom: 0;
    }

    /* Learning Rate Control */
    .lr-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .lr-header .title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--slate-300);
    }

    .lr-header .value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--yellow-400);
      background: rgba(250, 204, 21, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: var(--slate-700);
      border-radius: 3px;
      appearance: none;
      cursor: pointer;
      margin-bottom: 1rem;
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      background: var(--indigo-500);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    /* Preset Buttons */
    .presets-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
    }

    .preset-btn {
      text-align: left;
      padding: 0.5rem;
      border-radius: 0.375rem;
      border: 1px solid var(--slate-700);
      background: var(--slate-800);
      color: var(--slate-400);
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      border-color: var(--slate-500);
      color: var(--slate-200);
    }

    .preset-btn.active {
      background: var(--indigo-600);
      border-color: var(--indigo-500);
      color: white;
    }

    .preset-btn .name {
      font-size: 0.75rem;
      font-weight: 600;
      display: block;
    }

    .preset-btn .desc {
      font-size: 0.625rem;
      opacity: 0.7;
    }

    /* Schedule Toggle */
    .schedule-card {
      background: rgba(30, 41, 59, 0.5);
      padding: 1rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(51, 65, 85, 0.5);
    }

    .schedule-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .schedule-header .title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: var(--slate-300);
    }

    .toggle-switch {
      width: 40px;
      height: 20px;
      background: var(--slate-600);
      border-radius: 10px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s;
      border: none;
    }

    .toggle-switch.active {
      background: var(--emerald-500);
    }

    .toggle-switch .knob {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 14px;
      height: 14px;
      background: white;
      border-radius: 50%;
      transition: left 0.2s;
    }

    .toggle-switch.active .knob {
      left: 23px;
    }

    .schedule-card p {
      font-size: 0.75rem;
      color: var(--slate-500);
    }

    .schedule-card code {
      background: var(--slate-900);
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
    }

    /* Comparison Mode */
    .comparison-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem;
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 0.5rem;
      margin-bottom: 1rem;
    }

    .comparison-toggle .title {
      font-size: 0.875rem;
      color: var(--indigo-300);
    }

    /* Playback Controls */
    .playback-section {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--slate-700);
    }

    .playback-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }

    .btn-primary {
      flex: 1;
      background: var(--indigo-600);
      color: white;
    }

    .btn-primary:hover {
      background: var(--indigo-500);
    }

    .btn-primary.playing {
      background: var(--amber-500);
    }

    .btn-primary.playing:hover {
      background: var(--amber-400);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-secondary {
      padding: 0.75rem;
      background: var(--slate-800);
      color: var(--slate-300);
      border: 1px solid var(--slate-700);
    }

    .btn-secondary:hover {
      background: var(--slate-700);
    }

    /* Info Box */
    .info-box {
      background: rgba(30, 58, 138, 0.2);
      border: 1px solid rgba(37, 99, 235, 0.3);
      padding: 1rem;
      border-radius: 0.5rem;
    }

    .info-box .content {
      display: flex;
      gap: 0.5rem;
    }

    .info-box svg {
      flex-shrink: 0;
      color: var(--blue-400);
      margin-top: 2px;
    }

    .info-box .text {
      font-size: 0.75rem;
      color: #bfdbfe;
    }

    .info-box .text strong {
      display: block;
      margin-bottom: 0.25rem;
      color: #dbeafe;
    }

    .info-box .equation {
      font-family: 'JetBrains Mono', monospace;
      background: rgba(0, 0, 0, 0.2);
      padding: 0.25rem 0.5rem;
      margin: 0.5rem 0;
      border-radius: 0.25rem;
      text-align: center;
      display: block;
    }

    /* Status Explanation */
    .status-explanation {
      margin-top: 1rem;
      padding: 0.75rem;
      background: var(--slate-800);
      border-radius: 0.5rem;
      font-size: 0.75rem;
    }

    .status-explanation .title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .status-explanation.converging {
      border-left: 3px solid var(--emerald-500);
    }

    .status-explanation.oscillating {
      border-left: 3px solid var(--amber-500);
    }

    .status-explanation.diverging {
      border-left: 3px solid var(--red-500);
    }

    .status-explanation.converged {
      border-left: 3px solid var(--blue-500);
    }

    /* Icon styles */
    .icon {
      width: 20px;
      height: 20px;
    }

    .icon-sm {
      width: 16px;
      height: 16px;
    }

    .icon-lg {
      width: 24px;
      height: 24px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-left">
        <div class="header-icon">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/>
            <polyline points="17 6 23 6 23 12"/>
          </svg>
        </div>
        <div>
          <h1>Learning Rate Explorer</h1>
          <p>Understanding the Most Important Hyperparameter</p>
        </div>
      </div>
      <div class="header-right">
        <div id="statusBadge" class="status-badge converging">
          <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/>
          </svg>
          <span>Converging</span>
        </div>
        <div class="iteration-badge">
          Iteration: <span id="iterationCount">0</span>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main">
      <!-- Canvas -->
      <div class="canvas-container">
        <canvas id="canvas"></canvas>

        <!-- Stats Overlay -->
        <div class="stats-overlay">
          <h3>Live Statistics</h3>
          <div class="stat-row">
            <span class="label">Loss</span>
            <span class="value" id="statLoss">0.00000</span>
          </div>
          <div class="stat-row">
            <span class="label">Gradient Magnitude</span>
            <span class="value" id="statGradMag">0.000</span>
          </div>
          <div class="stat-row">
            <span class="label">Effective LR</span>
            <span class="value" id="statEffectiveLR">0.000</span>
          </div>
          <div class="stat-row">
            <span class="label">Step Size</span>
            <span class="value" id="statStepSize">0.000</span>
          </div>
          <div class="chart-section">
            <div class="label">Loss History</div>
            <canvas id="lossChart"></canvas>
          </div>
        </div>

        <!-- Legend (for comparison mode) -->
        <div class="legend" id="legend" style="display: none;">
          <h4>Learning Rates</h4>
          <div id="legendItems"></div>
        </div>

        <!-- Intro Overlay -->
        <div class="intro-overlay" id="introOverlay">
          <div class="intro-card">
            <h2>Ready to Explore?</h2>
            <p>See how learning rate affects gradient descent. Too small creeps slowly. Too large explodes. Find the sweet spot.</p>
            <p class="tip">ðŸ’¡ Drag to rotate â€¢ Scroll to zoom â€¢ Try the presets!</p>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar">
        <div class="sidebar-content">
          <!-- Learning Rate Control -->
          <div class="sidebar-section">
            <div class="lr-header">
              <div class="title">
                <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="#facc15" stroke-width="2">
                  <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
                </svg>
                Learning Rate (Î±)
              </div>
              <div class="value" id="lrValue">0.1200</div>
            </div>
            <input type="range" id="lrSlider" min="-3" max="-0.2" step="0.01" value="-0.92">
            <div class="presets-grid" id="presetButtons"></div>
          </div>

          <!-- Comparison Mode -->
          <div class="sidebar-section">
            <div class="comparison-toggle">
              <span class="title">Compare Multiple Rates</span>
              <button class="toggle-switch" id="comparisonToggle">
                <div class="knob"></div>
              </button>
            </div>

            <!-- Schedule Toggle -->
            <div class="schedule-card">
              <div class="schedule-header">
                <div class="title">
                  <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="#34d399" stroke-width="2">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
                  </svg>
                  LR Schedule (Decay)
                </div>
                <button class="toggle-switch" id="scheduleToggle">
                  <div class="knob"></div>
                </button>
              </div>
              <p>Reduces learning rate over time:<br><code>Î± = Î±â‚€ / (1 + 0.05t)</code></p>
            </div>
          </div>

          <!-- Status Explanation -->
          <div class="sidebar-section">
            <div class="status-explanation converging" id="statusExplanation">
              <div class="title">âœ“ Converging</div>
              <p>Loss is decreasing steadily. The optimizer is making good progress toward the minimum.</p>
            </div>
          </div>

          <!-- Info Box -->
          <div class="sidebar-section">
            <div class="info-box">
              <div class="content">
                <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/>
                </svg>
                <div class="text">
                  <strong>The Update Rule</strong>
                  <span class="equation">Î¸ = Î¸ - Î± Â· âˆ‡L(Î¸)</span>
                  If Î± is too large, the step overshoots the minimum. If too small, convergence takes forever.
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Playback Controls -->
        <div class="playback-section">
          <div class="playback-buttons">
            <button class="btn btn-primary" id="playBtn">
              <svg class="icon" id="playIcon" viewBox="0 0 24 24" fill="currentColor">
                <polygon points="5 3 19 12 5 21 5 3"/>
              </svg>
              <svg class="icon" id="pauseIcon" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
                <rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>
              </svg>
              <span id="playBtnText">Start Descent</span>
            </button>
            <button class="btn btn-secondary" id="resetBtn" title="Reset">
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================

    const START_POS = { x: 4, z: 3 };
    const MAX_PATH_POINTS = 2000;
    const MAX_HISTORY = 200;
    const PHYSICS_FPS = 30;

    const PRESETS = {
      TOO_SMALL: { label: "Too Small", lr: 0.005, color: '#60a5fa', desc: "Painfully slow" },
      GOOD: { label: "Just Right", lr: 0.12, color: '#4ade80', desc: "Efficient convergence" },
      OSCILLATING: { label: "High", lr: 0.45, color: '#fbbf24', desc: "Overshooting" },
      DIVERGING: { label: "Too Large", lr: 0.55, color: '#f87171', desc: "Explodes!" }
    };

    // Loss function: L(x, z) = (xÂ² + 2zÂ²) / 20
    // This elliptical bowl shows orientation sensitivity
    const lossFunction = (x, z) => (x * x + 2 * z * z) / 20;

    // Gradient: âˆ‡L = [2x/20, 4z/20] = [x/10, z/5]
    const gradient = (x, z) => ({ dx: x / 10, dz: z / 5 });

    const statusMessages = {
      converging: { title: "âœ“ Converging", text: "Loss is decreasing steadily. The optimizer is making good progress toward the minimum." },
      oscillating: { title: "âš  Oscillating", text: "The optimizer is overshooting and bouncing back. Learning rate may be too high." },
      diverging: { title: "âœ— Diverging", text: "Loss is increasing! The learning rate is too high â€” each step adds energy instead of removing it." },
      converged: { title: "â˜… Converged", text: "Reached the minimum! Gradient is near zero. The optimization succeeded." }
    };

    // ============================================
    // STATE
    // ============================================

    const state = {
      isPlaying: false,
      iteration: 0,
      learningRate: PRESETS.GOOD.lr,
      isScheduleEnabled: false,
      isComparisonMode: false,
      status: 'converging',
      lossHistory: [], // Ring buffer
      historyIndex: 0
    };

    // Simulation state for each optimizer (mutable for performance)
    let optimizers = [];

    // ============================================
    // THREE.JS SETUP
    // ============================================

    let scene, camera, renderer, controls, surfaceMesh;
    let intervalId = null;

    function initThree() {
      const canvas = document.getElementById('canvas');
      const container = canvas.parentElement;

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f172a);
      scene.fog = new THREE.Fog(0x0f172a, 15, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        100
      );
      camera.position.set(14, 12, 14);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI / 2 - 0.1;
      controls.minDistance = 5;
      controls.maxDistance = 40;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 15, 5);
      dirLight.castShadow = true;
      scene.add(dirLight);

      const fillLight = new THREE.DirectionalLight(0x6366f1, 0.2);
      fillLight.position.set(-5, 5, -5);
      scene.add(fillLight);

      // Grid
      const grid = new THREE.GridHelper(20, 20, 0x334155, 0x1e293b);
      grid.position.y = -0.05;
      scene.add(grid);

      // Create loss surface
      createSurface();

      // Resize handler
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    function createSurface() {
      const geometry = new THREE.PlaneGeometry(16, 16, 64, 64);
      const count = geometry.attributes.position.count;
      const colors = [];
      const colorObj = new THREE.Color();

      for (let i = 0; i < count; i++) {
        const x = geometry.attributes.position.getX(i);
        const z = geometry.attributes.position.getY(i);
        const y = lossFunction(x, z);

        geometry.attributes.position.setZ(i, y);

        // Color gradient: blue (low) -> green -> red (high)
        const t = Math.min(y / 3, 1);
        if (t < 0.5) {
          colorObj.setHSL(0.6 - t * 0.2, 0.7, 0.5);
        } else {
          colorObj.setHSL(0.4 - (t - 0.5) * 0.8, 0.7, 0.5);
        }
        colors.push(colorObj.r, colorObj.g, colorObj.b);
      }

      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeVertexNormals();

      // Wireframe mesh
      const wireMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,
        wireframe: true,
        side: THREE.DoubleSide,
        roughness: 0.8
      });

      // Solid transparent mesh for depth
      const solidMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide
      });

      const wireMesh = new THREE.Mesh(geometry, wireMaterial);
      wireMesh.rotation.x = -Math.PI / 2;
      scene.add(wireMesh);

      const solidMesh = new THREE.Mesh(geometry.clone(), solidMaterial);
      solidMesh.rotation.x = -Math.PI / 2;
      scene.add(solidMesh);

      surfaceMesh = wireMesh;
    }

    // ============================================
    // OPTIMIZER MANAGEMENT
    // ============================================

    function createOptimizer(lr, color, name) {
      // Ball
      const ballGeo = new THREE.SphereGeometry(0.25, 24, 24);
      const ballMat = new THREE.MeshPhongMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.4
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.castShadow = true;
      scene.add(ball);

      // Path trail
      const pathGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(MAX_PATH_POINTS * 3);
      pathGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      pathGeo.setDrawRange(0, 0);

      const pathMat = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      const pathLine = new THREE.Line(pathGeo, pathMat);
      scene.add(pathLine);

      // Gradient arrow
      const arrow = new THREE.ArrowHelper(
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(0, 0, 0),
        1,
        color,
        0.15,
        0.08
      );
      scene.add(arrow);

      return {
        name,
        lr,
        color,
        x: START_POS.x,
        z: START_POS.z,
        prevGradX: 0,
        prevGradZ: 0,
        path: [],
        pathIndex: 0,
        status: 'converging',
        ball,
        pathLine,
        pathGeo,
        arrow,
        effectiveLR: lr,
        stepSize: 0
      };
    }

    function removeOptimizer(opt) {
      scene.remove(opt.ball);
      scene.remove(opt.pathLine);
      scene.remove(opt.arrow);
      opt.ball.geometry.dispose();
      opt.ball.material.dispose();
      opt.pathGeo.dispose();
      opt.pathLine.material.dispose();
    }

    function resetOptimizers() {
      // Clear existing
      optimizers.forEach(removeOptimizer);
      optimizers = [];

      // Reset state
      state.isPlaying = false;
      state.iteration = 0;
      state.status = 'converging';
      state.lossHistory = [];
      state.historyIndex = 0;

      if (state.isComparisonMode) {
        // Create multiple optimizers for comparison
        optimizers.push(createOptimizer(PRESETS.TOO_SMALL.lr, PRESETS.TOO_SMALL.color, 'Too Small'));
        optimizers.push(createOptimizer(PRESETS.GOOD.lr, PRESETS.GOOD.color, 'Just Right'));
        optimizers.push(createOptimizer(PRESETS.OSCILLATING.lr, PRESETS.OSCILLATING.color, 'High'));
      } else {
        // Single optimizer with current learning rate
        optimizers.push(createOptimizer(state.learningRate, '#facc15', 'Current'));
      }

      updateVisuals();
      updateUI();
    }

    // ============================================
    // SIMULATION
    // ============================================

    function stepSimulation() {
      const currentIteration = state.iteration;
      let anyActive = false;
      let primaryStatus = 'converged';

      optimizers.forEach((opt, idx) => {
        if (opt.status === 'converged' || opt.status === 'diverging') return;

        anyActive = true;

        // Calculate gradient at current position
        const grad = gradient(opt.x, opt.z);
        const gradMag = Math.sqrt(grad.dx * grad.dx + grad.dz * grad.dz);

        // Effective learning rate with optional schedule
        let effLR = opt.lr;
        if (state.isScheduleEnabled) {
          effLR = opt.lr / (1 + currentIteration * 0.05);
        }
        opt.effectiveLR = effLR;

        // Calculate step
        const stepX = effLR * grad.dx;
        const stepZ = effLR * grad.dz;
        opt.stepSize = Math.sqrt(stepX * stepX + stepZ * stepZ);

        // Store current position in path (ring buffer)
        const y = lossFunction(opt.x, opt.z);
        if (opt.path.length < MAX_PATH_POINTS) {
          opt.path.push({ x: opt.x, y: y + 0.08, z: opt.z });
        } else {
          opt.path[opt.pathIndex] = { x: opt.x, y: y + 0.08, z: opt.z };
          opt.pathIndex = (opt.pathIndex + 1) % MAX_PATH_POINTS;
        }

        // Update position
        const newX = opt.x - stepX;
        const newZ = opt.z - stepZ;
        const newLoss = lossFunction(newX, newZ);
        const oldLoss = y;

        // Determine status
        let newStatus = 'converging';

        // Check for divergence
        if (Math.abs(newX) > 15 || Math.abs(newZ) > 15) {
          newStatus = 'diverging';
        } else if (newLoss > oldLoss * 1.2 && currentIteration > 2) {
          // Loss increased significantly
          newStatus = 'diverging';
        } else if (gradMag < 0.005) {
          // Converged
          newStatus = 'converged';
        } else {
          // Check for oscillation using gradient direction change
          const prevMag = Math.sqrt(opt.prevGradX * opt.prevGradX + opt.prevGradZ * opt.prevGradZ);
          if (prevMag > 0.01 && gradMag > 0.01) {
            const dot = (grad.dx * opt.prevGradX + grad.dz * opt.prevGradZ);
            const cosAngle = dot / (gradMag * prevMag);
            if (cosAngle < -0.3) {
              newStatus = 'oscillating';
            }
          }
        }

        opt.status = newStatus;
        opt.prevGradX = grad.dx;
        opt.prevGradZ = grad.dz;

        if (newStatus !== 'diverging') {
          opt.x = newX;
          opt.z = newZ;
        }

        // Track primary status (first optimizer or worst status)
        if (idx === 0 || newStatus === 'diverging') {
          primaryStatus = newStatus;
        }
      });

      // Update global state
      state.iteration = currentIteration + 1;
      state.status = primaryStatus;

      // Record loss history for primary optimizer
      if (optimizers.length > 0) {
        const primary = state.isComparisonMode ? optimizers[1] : optimizers[0]; // "Just Right" or single
        const loss = lossFunction(primary.x, primary.z);
        
        if (state.lossHistory.length < MAX_HISTORY) {
          state.lossHistory.push(loss);
        } else {
          state.lossHistory[state.historyIndex] = loss;
          state.historyIndex = (state.historyIndex + 1) % MAX_HISTORY;
        }
      }

      updateVisuals();
      updateUI();

      // Stop if all finished
      if (!anyActive) {
        togglePlay(false);
      }
    }

    function updateVisuals() {
      optimizers.forEach(opt => {
        const y = lossFunction(opt.x, opt.z);

        // Update ball position
        opt.ball.position.set(opt.x, y + 0.25, opt.z);
        opt.ball.visible = opt.status !== 'diverging' || state.iteration < 5;

        // Update path
        const positions = opt.pathGeo.attributes.position.array;
        const pathLen = Math.min(opt.path.length, MAX_PATH_POINTS);
        
        for (let i = 0; i < pathLen; i++) {
          const p = opt.path[i];
          positions[i * 3] = p.x;
          positions[i * 3 + 1] = p.y;
          positions[i * 3 + 2] = p.z;
        }

        opt.pathGeo.setDrawRange(0, pathLen);
        opt.pathGeo.attributes.position.needsUpdate = true;

        // Update gradient arrow
        if (opt.status !== 'converged' && opt.status !== 'diverging') {
          const grad = gradient(opt.x, opt.z);
          const gradMag = Math.sqrt(grad.dx * grad.dx + grad.dz * grad.dz);

          if (gradMag > 0.001) {
            // Arrow points in negative gradient direction (downhill)
            const dir = new THREE.Vector3(-grad.dx, 0, -grad.dz).normalize();
            const arrowLen = Math.min(opt.stepSize * 3, 2);

            opt.arrow.position.set(opt.x, y + 0.3, opt.z);
            opt.arrow.setDirection(dir);
            opt.arrow.setLength(arrowLen, 0.15, 0.08);
            opt.arrow.visible = true;
          }
        } else {
          opt.arrow.visible = false;
        }
      });
    }

    // ============================================
    // UI UPDATES
    // ============================================

    function updateUI() {
      // Iteration count
      document.getElementById('iterationCount').textContent = state.iteration;

      // Status badge
      const badge = document.getElementById('statusBadge');
      badge.className = `status-badge ${state.status}`;
      const statusLabels = { converging: 'Converging', oscillating: 'Oscillating', diverging: 'Diverging', converged: 'Converged' };
      badge.querySelector('span').textContent = statusLabels[state.status];

      // Status explanation
      const explanation = document.getElementById('statusExplanation');
      explanation.className = `status-explanation ${state.status}`;
      const msg = statusMessages[state.status];
      explanation.innerHTML = `<div class="title">${msg.title}</div><p>${msg.text}</p>`;

      // Stats (use first optimizer for single mode, "Just Right" for comparison)
      const primary = state.isComparisonMode && optimizers.length > 1 ? optimizers[1] : optimizers[0];
      if (primary) {
        const loss = lossFunction(primary.x, primary.z);
        const grad = gradient(primary.x, primary.z);
        const gradMag = Math.sqrt(grad.dx * grad.dx + grad.dz * grad.dz);

        document.getElementById('statLoss').textContent = loss.toFixed(5);
        document.getElementById('statGradMag').textContent = gradMag.toFixed(4);
        document.getElementById('statEffectiveLR').textContent = primary.effectiveLR.toFixed(4);
        document.getElementById('statStepSize').textContent = primary.stepSize.toFixed(4);
      }

      // Update chart
      updateChart();

      // Update intro overlay
      const intro = document.getElementById('introOverlay');
      if (state.iteration > 0 || state.isPlaying) {
        intro.querySelector('.intro-card').classList.add('hidden');
      } else {
        intro.querySelector('.intro-card').classList.remove('hidden');
      }

      // Update legend visibility
      document.getElementById('legend').style.display = state.isComparisonMode ? 'block' : 'none';

      // Update play button
      updatePlayButton();
    }

    function updateChart() {
      const canvas = document.getElementById('lossChart');
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      if (state.lossHistory.length === 0) return;

      // Get ordered history from ring buffer
      const orderedHistory = [];
      if (state.lossHistory.length < MAX_HISTORY) {
        orderedHistory.push(...state.lossHistory);
      } else {
        for (let i = 0; i < MAX_HISTORY; i++) {
          orderedHistory.push(state.lossHistory[(state.historyIndex + i) % MAX_HISTORY]);
        }
      }

      const maxLoss = Math.max(...orderedHistory, 0.1);
      const stepX = w / Math.max(orderedHistory.length - 1, 1);

      ctx.beginPath();
      ctx.strokeStyle = '#22d3ee';
      ctx.lineWidth = 2;

      orderedHistory.forEach((loss, i) => {
        const x = i * stepX;
        const y = h - (Math.min(loss / maxLoss, 1) * (h - 4)) - 2;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });

      ctx.stroke();
    }

    function updatePlayButton() {
      const btn = document.getElementById('playBtn');
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');
      const text = document.getElementById('playBtnText');

      const allDone = optimizers.every(o => o.status === 'converged' || o.status === 'diverging');

      if (state.isPlaying) {
        btn.classList.add('playing');
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'block';
        text.textContent = 'Pause';
      } else {
        btn.classList.remove('playing');
        playIcon.style.display = 'block';
        pauseIcon.style.display = 'none';
        text.textContent = 'Start Descent';
      }

      btn.disabled = allDone && !state.isPlaying;
    }

    function updateLegend() {
      const container = document.getElementById('legendItems');
      if (state.isComparisonMode) {
        container.innerHTML = Object.entries(PRESETS)
          .filter(([key]) => key !== 'DIVERGING')
          .map(([key, preset]) => `
            <div class="legend-item">
              <div class="legend-dot" style="background: ${preset.color}"></div>
              <span>${preset.label}</span>
              <span class="lr">(Î±=${preset.lr})</span>
            </div>
          `).join('');
      }
    }

    function updatePresetButtons() {
      const container = document.getElementById('presetButtons');
      container.innerHTML = Object.entries(PRESETS).map(([key, preset]) => {
        const isActive = !state.isComparisonMode && Math.abs(state.learningRate - preset.lr) < 0.001;
        return `
          <button class="preset-btn ${isActive ? 'active' : ''}" data-preset="${key}">
            <span class="name">${preset.label}</span>
            <span class="desc">${preset.desc}</span>
          </button>
        `;
      }).join('');

      // Attach click handlers
      container.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const key = btn.dataset.preset;
          state.learningRate = PRESETS[key].lr;
          document.getElementById('lrSlider').value = Math.log10(state.learningRate);
          document.getElementById('lrValue').textContent = state.learningRate.toFixed(4);
          
          if (state.isComparisonMode) {
            document.getElementById('comparisonToggle').click(); // Turn off comparison
          }
          
          resetOptimizers();
          setTimeout(() => togglePlay(true), 50);
        });
      });
    }

    // ============================================
    // CONTROLS
    // ============================================

    function togglePlay(forceState = null) {
      state.isPlaying = forceState !== null ? forceState : !state.isPlaying;

      if (state.isPlaying) {
        intervalId = setInterval(stepSimulation, 1000 / PHYSICS_FPS);
      } else if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }

      updatePlayButton();
    }

    function setupEventHandlers() {
      // Play/Pause
      document.getElementById('playBtn').addEventListener('click', () => togglePlay());

      // Reset
      document.getElementById('resetBtn').addEventListener('click', () => {
        resetOptimizers();
      });

      // Learning rate slider
      const lrSlider = document.getElementById('lrSlider');
      lrSlider.addEventListener('input', (e) => {
        state.learningRate = Math.pow(10, parseFloat(e.target.value));
        document.getElementById('lrValue').textContent = state.learningRate.toFixed(4);

        // If diverged or converged, reset on slider change
        if (state.status === 'diverging' || state.status === 'converged') {
          resetOptimizers();
        }

        // Update preset highlighting
        updatePresetButtons();
      });

      // Schedule toggle
      document.getElementById('scheduleToggle').addEventListener('click', (e) => {
        state.isScheduleEnabled = !state.isScheduleEnabled;
        e.currentTarget.classList.toggle('active', state.isScheduleEnabled);
      });

      // Comparison mode toggle
      document.getElementById('comparisonToggle').addEventListener('click', (e) => {
        state.isComparisonMode = !state.isComparisonMode;
        e.currentTarget.classList.toggle('active', state.isComparisonMode);
        updateLegend();
        resetOptimizers();
      });

      // Presets
      updatePresetButtons();
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    function init() {
      initThree();
      resetOptimizers();
      setupEventHandlers();
      updateLegend();
      updateUI();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autoencoder Latent Space Navigator | Neural Network Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Inter', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        .ui-panel { z-index: 10; backdrop-filter: blur(12px); background-color: rgba(15, 23, 42, 0.9); }
        
        input[type=range] { -webkit-appearance: none; appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #10b981; cursor: pointer; margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px;
        }
        
        .latent-point {
            transition: all 0.2s ease;
        }
        .latent-point:hover {
            transform: scale(1.5);
        }
        
        .reconstruction-canvas {
            image-rendering: pixelated;
            border: 2px solid rgba(16, 185, 129, 0.5);
            border-radius: 8px;
        }
        
        .pipeline-stage {
            transition: all 0.3s ease;
        }
        .pipeline-stage.active {
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
        }
        
        .dim-slider {
            transition: all 0.2s ease;
        }
        .dim-slider:hover {
            background-color: rgba(16, 185, 129, 0.2);
        }
        
        mjx-container { font-size: 0.95em !important; color: white !important; }
        
        .interpolation-frame {
            border: 1px solid rgba(16, 185, 129, 0.3);
            transition: all 0.2s ease;
        }
        .interpolation-frame:hover {
            border-color: rgba(16, 185, 129, 0.8);
            transform: scale(1.1);
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="text-white">
    <div id="canvas-container"></div>

    <!-- Header -->
    <div class="absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none z-20">
        <div class="ui-panel p-5 rounded-xl border border-slate-700 pointer-events-auto shadow-2xl max-w-md">
            <h1 class="text-2xl font-bold bg-gradient-to-r from-emerald-400 to-cyan-400 bg-clip-text text-transparent mb-1">
                Latent Space Navigator
            </h1>
            <p class="text-xs text-slate-400 mb-4">Explore VAE latent space and watch reconstructions morph</p>
            
            <!-- Dataset Selection -->
            <div class="mb-4">
                <label class="text-xs text-slate-400 block mb-2">Dataset</label>
                <div class="flex gap-2">
                    <button onclick="app.setDataset('digits')" id="ds-digits" class="ds-btn px-3 py-2 text-xs rounded-lg bg-emerald-600">
                        MNIST Digits
                    </button>
                    <button onclick="app.setDataset('shapes')" id="ds-shapes" class="ds-btn px-3 py-2 text-xs rounded-lg bg-slate-700 hover:bg-slate-600">
                        Shapes
                    </button>
                    <button onclick="app.setDataset('faces')" id="ds-faces" class="ds-btn px-3 py-2 text-xs rounded-lg bg-slate-700 hover:bg-slate-600">
                        Faces (2D)
                    </button>
                </div>
            </div>

            <!-- Math Display -->
            <div id="math-display" class="bg-slate-900/50 p-3 rounded-lg border border-slate-700 min-h-[50px] flex items-center justify-center text-sm">
                $$ z = \mu + \sigma \cdot \epsilon, \quad \epsilon \sim \mathcal{N}(0, I) $$
            </div>
            <p id="math-explanation" class="text-xs text-slate-400 mt-2 text-center">
                VAE: Reparameterization trick for sampling
            </p>
        </div>

        <!-- Reconstruction Display -->
        <div class="ui-panel p-4 rounded-xl border border-slate-700 pointer-events-auto">
            <h3 class="text-sm font-bold text-emerald-400 mb-3">Live Reconstruction</h3>
            <canvas id="reconstruction-canvas" width="112" height="112" class="reconstruction-canvas"></canvas>
            <p class="text-xs text-slate-400 mt-2 text-center" id="recon-label">Position: (0.00, 0.00)</p>
        </div>
    </div>

    <!-- Pipeline Visualization -->
    <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none z-15 hidden" id="pipeline-view">
        <div class="flex items-center gap-4">
            <div class="pipeline-stage ui-panel p-4 rounded-xl border border-slate-700 text-center">
                <div class="text-3xl mb-2">üì∑</div>
                <p class="text-xs text-slate-400">Input</p>
                <p class="text-xs font-mono text-emerald-400">28√ó28</p>
            </div>
            <div class="text-2xl text-slate-500">‚Üí</div>
            <div class="pipeline-stage ui-panel p-4 rounded-xl border border-emerald-500 text-center">
                <div class="text-3xl mb-2">üîí</div>
                <p class="text-xs text-slate-400">Encoder</p>
                <p class="text-xs font-mono text-emerald-400">784‚Üí128‚Üí32</p>
            </div>
            <div class="text-2xl text-slate-500">‚Üí</div>
            <div class="pipeline-stage active ui-panel p-4 rounded-xl border border-cyan-500 text-center">
                <div class="text-3xl mb-2">üéØ</div>
                <p class="text-xs text-slate-400">Latent</p>
                <p class="text-xs font-mono text-cyan-400">z ‚àà ‚Ñù¬≤</p>
            </div>
            <div class="text-2xl text-slate-500">‚Üí</div>
            <div class="pipeline-stage ui-panel p-4 rounded-xl border border-purple-500 text-center">
                <div class="text-3xl mb-2">üîì</div>
                <p class="text-xs text-slate-400">Decoder</p>
                <p class="text-xs font-mono text-purple-400">32‚Üí128‚Üí784</p>
            </div>
            <div class="text-2xl text-slate-500">‚Üí</div>
            <div class="pipeline-stage ui-panel p-4 rounded-xl border border-slate-700 text-center">
                <div class="text-3xl mb-2">üñºÔ∏è</div>
                <p class="text-xs text-slate-400">Output</p>
                <p class="text-xs font-mono text-emerald-400">28√ó28</p>
            </div>
        </div>
    </div>

    <!-- Control Panel (Bottom) -->
    <div class="absolute bottom-6 left-4 right-4 flex justify-center pointer-events-none z-20">
        <div class="ui-panel p-5 rounded-xl border border-slate-700 pointer-events-auto shadow-2xl w-full max-w-5xl">
            <div class="flex gap-6">
                <!-- Latent Dimensions -->
                <div class="flex-1" id="dim-panel">
                    <h3 class="text-sm font-bold text-cyan-400 mb-3">Latent Dimensions</h3>
                    <div class="space-y-2">
                        <div class="dim-slider flex items-center gap-2 p-2 rounded">
                            <span class="text-xs text-slate-400 w-8">z‚ÇÅ</span>
                            <input type="range" id="dim-0" min="-3" max="3" step="0.1" value="0" class="flex-1">
                            <span id="dim-0-val" class="text-xs text-emerald-400 w-12 text-right">0.00</span>
                        </div>
                        <div class="dim-slider flex items-center gap-2 p-2 rounded">
                            <span class="text-xs text-slate-400 w-8">z‚ÇÇ</span>
                            <input type="range" id="dim-1" min="-3" max="3" step="0.1" value="0" class="flex-1">
                            <span id="dim-1-val" class="text-xs text-emerald-400 w-12 text-right">0.00</span>
                        </div>
                    </div>
                    <p class="text-xs text-slate-500 mt-2">Drag to explore latent space</p>
                </div>

                <!-- Interpolation -->
                <div class="flex-1" id="interp-panel">
                    <h3 class="text-sm font-bold text-purple-400 mb-3">Interpolation</h3>
                    <div class="flex gap-2 mb-3">
                        <button onclick="app.setInterpPoint('start')" id="btn-start" class="px-3 py-2 text-xs rounded-lg bg-slate-700 hover:bg-slate-600">
                            Set Start
                        </button>
                        <button onclick="app.setInterpPoint('end')" id="btn-end" class="px-3 py-2 text-xs rounded-lg bg-slate-700 hover:bg-slate-600">
                            Set End
                        </button>
                        <button onclick="app.playInterpolation()" id="btn-interp" class="px-3 py-2 text-xs rounded-lg bg-purple-600 hover:bg-purple-500">
                            ‚ñ∂ Interpolate
                        </button>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-slate-400">t:</span>
                        <input type="range" id="interp-slider" min="0" max="1" step="0.01" value="0" class="flex-1">
                        <span id="interp-val" class="text-xs text-purple-400 w-10">0.00</span>
                    </div>
                </div>

                <!-- Controls -->
                <div class="flex-1" id="ctrl-panel">
                    <h3 class="text-sm font-bold text-amber-400 mb-3">Controls</h3>
                    <div class="flex gap-2 flex-wrap">
                        <button onclick="app.randomSample()" class="px-3 py-2 text-xs rounded-lg bg-amber-600 hover:bg-amber-500">
                            üé≤ Random Sample
                        </button>
                        <button onclick="app.resetPosition()" class="px-3 py-2 text-xs rounded-lg bg-slate-700 hover:bg-slate-600">
                            ‚Ü∫ Reset
                        </button>
                        <button onclick="app.togglePipeline()" class="px-3 py-2 text-xs rounded-lg bg-slate-700 hover:bg-slate-600">
                            üìä Pipeline
                        </button>
                    </div>
                    <div class="flex items-center gap-2 mt-3">
                        <span class="text-xs text-slate-400">View:</span>
                        <button onclick="app.setView('2d')" id="view-2d" class="view-btn px-2 py-1 text-xs rounded bg-emerald-600">2D</button>
                        <button onclick="app.setView('3d')" id="view-3d" class="view-btn px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600">3D</button>
                    </div>
                </div>

                <!-- Interpolation Preview -->
                <div class="w-64" id="interp-preview">
                    <h3 class="text-sm font-bold text-green-400 mb-3">Interpolation Path</h3>
                    <div id="interp-frames" class="flex gap-1 overflow-x-auto">
                        <!-- Frames will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Legend -->
    <div class="absolute bottom-32 left-4 ui-panel p-3 rounded-lg border border-slate-700 pointer-events-auto z-20">
        <h4 class="text-xs font-bold text-slate-400 mb-2">Class Legend</h4>
        <div id="legend" class="flex flex-wrap gap-2 max-w-xs"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        class LatentSpaceNavigator {
            constructor() {
                this.dataset = 'digits';
                this.latentPos = [0, 0];
                this.latentDims = 2;
                this.viewMode = '2d';
                
                // Interpolation
                this.interpStart = null;
                this.interpEnd = null;
                this.interpT = 0;
                this.isInterpolating = false;
                
                // Data points
                this.dataPoints = [];
                this.pointMeshes = [];
                this.currentMarker = null;
                this.interpLine = null;
                
                // Colors for classes
                this.classColors = [
                    0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7,
                    0x00b894, 0xfd79a8, 0x00cec9, 0xe17055, 0x74b9ff
                ];
                
                // Scene
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.generateDataPoints();
                this.createVisualization();
                this.setupEventListeners();
                this.updateReconstruction();
                this.createLegend();
                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0f172a);
                
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
                this.camera.position.set(0, 0, 15);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // Lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambient);
                
                const point = new THREE.PointLight(0xffffff, 1);
                point.position.set(10, 10, 10);
                this.scene.add(point);
                
                window.addEventListener('resize', () => this.onResize());
            }

            generateDataPoints() {
                this.dataPoints = [];
                const numPoints = 200;
                
                if (this.dataset === 'digits') {
                    // Generate clustered points for digits 0-9
                    for (let digit = 0; digit < 10; digit++) {
                        const cx = (digit % 5 - 2) * 1.5 + (Math.random() - 0.5) * 0.5;
                        const cy = (Math.floor(digit / 5) - 0.5) * 2 + (Math.random() - 0.5) * 0.5;
                        
                        for (let i = 0; i < numPoints / 10; i++) {
                            this.dataPoints.push({
                                x: cx + (Math.random() - 0.5) * 1.2,
                                y: cy + (Math.random() - 0.5) * 1.2,
                                z: (Math.random() - 0.5) * 0.5,
                                class: digit,
                                label: digit.toString()
                            });
                        }
                    }
                } else if (this.dataset === 'shapes') {
                    const shapes = ['circle', 'square', 'triangle', 'star'];
                    shapes.forEach((shape, idx) => {
                        const cx = (idx % 2 - 0.5) * 3;
                        const cy = (Math.floor(idx / 2) - 0.5) * 3;
                        
                        for (let i = 0; i < numPoints / 4; i++) {
                            this.dataPoints.push({
                                x: cx + (Math.random() - 0.5) * 2,
                                y: cy + (Math.random() - 0.5) * 2,
                                z: (Math.random() - 0.5) * 0.5,
                                class: idx,
                                label: shape
                            });
                        }
                    });
                } else if (this.dataset === 'faces') {
                    // Faces with attributes (smile, glasses)
                    for (let i = 0; i < numPoints; i++) {
                        const smile = Math.random() > 0.5;
                        const glasses = Math.random() > 0.5;
                        const cls = (smile ? 2 : 0) + (glasses ? 1 : 0);
                        
                        this.dataPoints.push({
                            x: (smile ? 1 : -1) * (1 + Math.random()),
                            y: (glasses ? 1 : -1) * (1 + Math.random()),
                            z: (Math.random() - 0.5) * 0.5,
                            class: cls,
                            label: `${smile ? 'smile' : 'neutral'} ${glasses ? '+glasses' : ''}`
                        });
                    }
                }
            }

            createVisualization() {
                this.clearVisualization();
                
                // Create point cloud
                const pointGeo = new THREE.SphereGeometry(0.08, 16, 16);
                
                this.dataPoints.forEach(point => {
                    const mat = new THREE.MeshPhongMaterial({
                        color: this.classColors[point.class % this.classColors.length],
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const mesh = new THREE.Mesh(pointGeo, mat);
                    mesh.position.set(point.x, point.y, this.viewMode === '3d' ? point.z : 0);
                    mesh.userData = point;
                    
                    this.scene.add(mesh);
                    this.pointMeshes.push(mesh);
                });
                
                // Current position marker
                const markerGeo = new THREE.SphereGeometry(0.25, 32, 32);
                const markerMat = new THREE.MeshPhongMaterial({
                    color: 0x10b981,
                    emissive: 0x059669,
                    emissiveIntensity: 0.5
                });
                this.currentMarker = new THREE.Mesh(markerGeo, markerMat);
                this.currentMarker.position.set(this.latentPos[0], this.latentPos[1], 0);
                this.scene.add(this.currentMarker);
                
                // Marker ring
                const ringGeo = new THREE.RingGeometry(0.3, 0.4, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x34d399, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                this.currentMarker.add(ring);
                
                // Axes
                this.createAxes();
                
                // Grid
                const gridHelper = new THREE.GridHelper(10, 20, 0x1e3a5f, 0x0f2942);
                gridHelper.rotation.x = Math.PI / 2;
                this.scene.add(gridHelper);
            }

            clearVisualization() {
                this.pointMeshes.forEach(mesh => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
                this.pointMeshes = [];
                
                if (this.currentMarker) {
                    this.scene.remove(this.currentMarker);
                }
                
                if (this.interpLine) {
                    this.scene.remove(this.interpLine);
                }
                
                // Remove old axes and grid
                this.scene.children = this.scene.children.filter(child => 
                    child.type === 'AmbientLight' || child.type === 'PointLight'
                );
            }

            createAxes() {
                // X axis
                const xGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-5, 0, 0),
                    new THREE.Vector3(5, 0, 0)
                ]);
                const xMat = new THREE.LineBasicMaterial({ color: 0xef4444 });
                this.scene.add(new THREE.Line(xGeo, xMat));
                
                // Y axis
                const yGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -5, 0),
                    new THREE.Vector3(0, 5, 0)
                ]);
                const yMat = new THREE.LineBasicMaterial({ color: 0x22c55e });
                this.scene.add(new THREE.Line(yGeo, yMat));
                
                // Labels
                this.addAxisLabel('z‚ÇÅ', 5.5, 0, 0, 0xef4444);
                this.addAxisLabel('z‚ÇÇ', 0, 5.5, 0, 0x22c55e);
            }

            addAxisLabel(text, x, y, z, color) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, 32, 24);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.set(x, y, z);
                sprite.scale.set(2, 1, 1);
                this.scene.add(sprite);
            }

            updateReconstruction() {
                const canvas = document.getElementById('reconstruction-canvas');
                const ctx = canvas.getContext('2d');
                const size = 28;
                const scale = 4;
                
                // Generate reconstruction based on latent position
                const imageData = ctx.createImageData(size, size);
                
                // Mock VAE decoder - creates patterns based on latent position
                const z1 = this.latentPos[0];
                const z2 = this.latentPos[1];
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        let val = 0;
                        
                        if (this.dataset === 'digits') {
                            // Generate digit-like patterns
                            const cx = size / 2;
                            const cy = size / 2;
                            const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                            
                            // Different patterns based on latent position
                            const pattern = Math.floor((z1 + 3) / 0.6) % 10;
                            
                            if (pattern < 3) {
                                // Circle-like (0, 8, 9)
                                val = Math.abs(dist - 8) < 3 ? 255 : 0;
                            } else if (pattern < 5) {
                                // Vertical line (1, 7)
                                val = Math.abs(x - cx) < 2 ? 255 : 0;
                            } else if (pattern < 7) {
                                // Cross (4, +)
                                val = (Math.abs(x - cx) < 2 || Math.abs(y - cy) < 2) ? 255 : 0;
                            } else {
                                // Curves (3, 5, 6)
                                const curve = Math.sin((x - cx) * 0.3 + z2) * 5;
                                val = Math.abs(y - cy - curve) < 3 ? 255 : 0;
                            }
                            
                            // Add noise based on z2
                            val = Math.min(255, Math.max(0, val + z2 * 20));
                        } else if (this.dataset === 'shapes') {
                            const cx = size / 2;
                            const cy = size / 2;
                            const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                            
                            if (z1 < 0 && z2 < 0) {
                                // Circle
                                val = Math.abs(dist - 10) < 2 ? 255 : 0;
                            } else if (z1 >= 0 && z2 < 0) {
                                // Square
                                val = (Math.abs(x - cx) < 10 && Math.abs(y - cy) < 10 &&
                                       (Math.abs(x - cx) > 8 || Math.abs(y - cy) > 8)) ? 255 : 0;
                            } else if (z1 < 0 && z2 >= 0) {
                                // Triangle
                                val = (y > cy - 10 && y < cy + 10 && 
                                       Math.abs(x - cx) < (cy + 10 - y) * 0.7) ? 255 : 0;
                            } else {
                                // Star
                                const angle = Math.atan2(y - cy, x - cx);
                                const starR = 8 + Math.sin(angle * 5) * 4;
                                val = Math.abs(dist - starR) < 2 ? 255 : 0;
                            }
                        } else {
                            // Face-like pattern
                            const cx = size / 2;
                            const cy = size / 2;
                            
                            // Face outline
                            const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                            if (Math.abs(dist - 12) < 1.5) val = 255;
                            
                            // Eyes
                            const leftEyeDist = Math.sqrt((x - cx + 4) ** 2 + (y - cy + 4) ** 2);
                            const rightEyeDist = Math.sqrt((x - cx - 4) ** 2 + (y - cy + 4) ** 2);
                            if (leftEyeDist < 2 || rightEyeDist < 2) val = 255;
                            
                            // Glasses (if z2 > 0)
                            if (z2 > 0) {
                                if (Math.abs(y - cy + 4) < 1 && x > cx - 10 && x < cx + 10) val = 255;
                            }
                            
                            // Mouth (smile if z1 > 0)
                            const mouthCurve = z1 > 0 ? Math.pow((x - cx) / 6, 2) : 0;
                            if (Math.abs(y - cy - 5 - mouthCurve) < 1 && Math.abs(x - cx) < 6) val = 255;
                        }
                        
                        const idx = (y * size + x) * 4;
                        imageData.data[idx] = val;
                        imageData.data[idx + 1] = val;
                        imageData.data[idx + 2] = val;
                        imageData.data[idx + 3] = 255;
                    }
                }
                
                // Clear and draw scaled
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Create temp canvas for scaling
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = size;
                tempCanvas.height = size;
                tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
                
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
                
                // Update label
                document.getElementById('recon-label').textContent = 
                    `Position: (${this.latentPos[0].toFixed(2)}, ${this.latentPos[1].toFixed(2)})`;
            }

            createLegend() {
                const legend = document.getElementById('legend');
                legend.innerHTML = '';
                
                let items = [];
                if (this.dataset === 'digits') {
                    items = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                } else if (this.dataset === 'shapes') {
                    items = ['Circle', 'Square', 'Triangle', 'Star'];
                } else {
                    items = ['Neutral', 'Glasses', 'Smile', 'Both'];
                }
                
                items.forEach((item, i) => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-1';
                    div.innerHTML = `
                        <div class="w-3 h-3 rounded-full" style="background-color: #${this.classColors[i].toString(16).padStart(6, '0')}"></div>
                        <span class="text-xs text-slate-400">${item}</span>
                    `;
                    legend.appendChild(div);
                });
            }

            setDataset(dataset) {
                this.dataset = dataset;
                
                // Update buttons
                document.querySelectorAll('.ds-btn').forEach(btn => {
                    btn.classList.remove('bg-emerald-600');
                    btn.classList.add('bg-slate-700');
                });
                document.getElementById(`ds-${dataset}`).classList.add('bg-emerald-600');
                document.getElementById(`ds-${dataset}`).classList.remove('bg-slate-700');
                
                this.generateDataPoints();
                this.createVisualization();
                this.createLegend();
                this.updateReconstruction();
            }

            setView(view) {
                this.viewMode = view;
                
                document.querySelectorAll('.view-btn').forEach(btn => {
                    btn.classList.remove('bg-emerald-600');
                    btn.classList.add('bg-slate-700');
                });
                document.getElementById(`view-${view}`).classList.add('bg-emerald-600');
                document.getElementById(`view-${view}`).classList.remove('bg-slate-700');
                
                if (view === '2d') {
                    this.camera.position.set(0, 0, 15);
                    this.controls.enableRotate = false;
                } else {
                    this.camera.position.set(10, 8, 10);
                    this.controls.enableRotate = true;
                }
                
                this.createVisualization();
            }

            setInterpPoint(type) {
                if (type === 'start') {
                    this.interpStart = [...this.latentPos];
                    document.getElementById('btn-start').classList.add('bg-green-600');
                    document.getElementById('btn-start').classList.remove('bg-slate-700');
                } else {
                    this.interpEnd = [...this.latentPos];
                    document.getElementById('btn-end').classList.add('bg-red-600');
                    document.getElementById('btn-end').classList.remove('bg-slate-700');
                }
                
                this.updateInterpLine();
            }

            updateInterpLine() {
                if (this.interpLine) {
                    this.scene.remove(this.interpLine);
                }
                
                if (this.interpStart && this.interpEnd) {
                    const points = [];
                    for (let t = 0; t <= 1; t += 0.05) {
                        points.push(new THREE.Vector3(
                            this.interpStart[0] * (1 - t) + this.interpEnd[0] * t,
                            this.interpStart[1] * (1 - t) + this.interpEnd[1] * t,
                            0.1
                        ));
                    }
                    
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const mat = new THREE.LineDashedMaterial({
                        color: 0xa855f7,
                        dashSize: 0.2,
                        gapSize: 0.1
                    });
                    
                    this.interpLine = new THREE.Line(geo, mat);
                    this.interpLine.computeLineDistances();
                    this.scene.add(this.interpLine);
                    
                    // Update interpolation preview
                    this.updateInterpPreview();
                }
            }

            updateInterpPreview() {
                if (!this.interpStart || !this.interpEnd) return;
                
                const container = document.getElementById('interp-frames');
                container.innerHTML = '';
                
                for (let t = 0; t <= 1; t += 0.2) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 28;
                    canvas.height = 28;
                    canvas.className = 'interpolation-frame rounded';
                    canvas.style.width = '35px';
                    canvas.style.height = '35px';
                    
                    // Temporarily set position and render
                    const origPos = [...this.latentPos];
                    this.latentPos = [
                        this.interpStart[0] * (1 - t) + this.interpEnd[0] * t,
                        this.interpStart[1] * (1 - t) + this.interpEnd[1] * t
                    ];
                    
                    // Mini reconstruction
                    const ctx = canvas.getContext('2d');
                    const mainCanvas = document.getElementById('reconstruction-canvas');
                    this.updateReconstruction();
                    ctx.drawImage(mainCanvas, 0, 0, 28, 28);
                    
                    this.latentPos = origPos;
                    container.appendChild(canvas);
                }
                
                this.updateReconstruction();
            }

            playInterpolation() {
                if (!this.interpStart || !this.interpEnd || this.isInterpolating) return;
                
                this.isInterpolating = true;
                this.interpT = 0;
                
                const animate = () => {
                    if (this.interpT > 1) {
                        this.isInterpolating = false;
                        return;
                    }
                    
                    this.latentPos = [
                        this.interpStart[0] * (1 - this.interpT) + this.interpEnd[0] * this.interpT,
                        this.interpStart[1] * (1 - this.interpT) + this.interpEnd[1] * this.interpT
                    ];
                    
                    this.updateSliders();
                    this.updateMarker();
                    this.updateReconstruction();
                    
                    document.getElementById('interp-slider').value = this.interpT;
                    document.getElementById('interp-val').textContent = this.interpT.toFixed(2);
                    
                    this.interpT += 0.02;
                    requestAnimationFrame(animate);
                };
                
                animate();
            }

            randomSample() {
                // Sample from standard normal (approximately)
                const u1 = Math.random();
                const u2 = Math.random();
                const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
                
                this.latentPos = [z1, z2];
                this.updateSliders();
                this.updateMarker();
                this.updateReconstruction();
            }

            resetPosition() {
                this.latentPos = [0, 0];
                this.interpStart = null;
                this.interpEnd = null;
                
                document.getElementById('btn-start').classList.remove('bg-green-600');
                document.getElementById('btn-start').classList.add('bg-slate-700');
                document.getElementById('btn-end').classList.remove('bg-red-600');
                document.getElementById('btn-end').classList.add('bg-slate-700');
                
                if (this.interpLine) {
                    this.scene.remove(this.interpLine);
                    this.interpLine = null;
                }
                
                document.getElementById('interp-frames').innerHTML = '';
                
                this.updateSliders();
                this.updateMarker();
                this.updateReconstruction();
            }

            togglePipeline() {
                const pipeline = document.getElementById('pipeline-view');
                pipeline.classList.toggle('hidden');
            }

            updateSliders() {
                document.getElementById('dim-0').value = this.latentPos[0];
                document.getElementById('dim-1').value = this.latentPos[1];
                document.getElementById('dim-0-val').textContent = this.latentPos[0].toFixed(2);
                document.getElementById('dim-1-val').textContent = this.latentPos[1].toFixed(2);
            }

            updateMarker() {
                if (this.currentMarker) {
                    this.currentMarker.position.set(this.latentPos[0], this.latentPos[1], 0.1);
                }
            }

            setupEventListeners() {
                // Dimension sliders
                document.getElementById('dim-0').addEventListener('input', (e) => {
                    this.latentPos[0] = parseFloat(e.target.value);
                    document.getElementById('dim-0-val').textContent = this.latentPos[0].toFixed(2);
                    this.updateMarker();
                    this.updateReconstruction();
                });
                
                document.getElementById('dim-1').addEventListener('input', (e) => {
                    this.latentPos[1] = parseFloat(e.target.value);
                    document.getElementById('dim-1-val').textContent = this.latentPos[1].toFixed(2);
                    this.updateMarker();
                    this.updateReconstruction();
                });
                
                // Interpolation slider
                document.getElementById('interp-slider').addEventListener('input', (e) => {
                    if (!this.interpStart || !this.interpEnd) return;
                    
                    const t = parseFloat(e.target.value);
                    document.getElementById('interp-val').textContent = t.toFixed(2);
                    
                    this.latentPos = [
                        this.interpStart[0] * (1 - t) + this.interpEnd[0] * t,
                        this.interpStart[1] * (1 - t) + this.interpEnd[1] * t
                    ];
                    
                    this.updateSliders();
                    this.updateMarker();
                    this.updateReconstruction();
                });
                
                // Click on canvas to set position
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (this.viewMode !== '2d') return;
                    
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const mouse = new THREE.Vector2(
                        ((e.clientX - rect.left) / rect.width) * 2 - 1,
                        -((e.clientY - rect.top) / rect.height) * 2 + 1
                    );
                    
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, this.camera);
                    
                    // Create a plane at z=0
                    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                    const intersection = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersection);
                    
                    if (intersection) {
                        this.latentPos = [
                            Math.max(-3, Math.min(3, intersection.x)),
                            Math.max(-3, Math.min(3, intersection.y))
                        ];
                        this.updateSliders();
                        this.updateMarker();
                        this.updateReconstruction();
                    }
                });
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                
                // Pulse effect on current marker
                if (this.currentMarker) {
                    const scale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
                    this.currentMarker.scale.set(scale, scale, scale);
                }
                
                // Rotate point cloud slightly in 3D mode
                if (this.viewMode === '3d') {
                    this.pointMeshes.forEach((mesh, i) => {
                        mesh.position.z = mesh.userData.z + Math.sin(Date.now() * 0.001 + i * 0.1) * 0.05;
                    });
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        const app = new LatentSpaceNavigator();
        window.app = app;
    </script>
</body>
</html>

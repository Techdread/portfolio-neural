<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Gradient Vector - B3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            margin-top: -4px;
        }
        .hint-box {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 font-sans overflow-hidden flex flex-col h-screen">

    <!-- Header -->
    <header class="bg-slate-800 border-b border-slate-700 p-4 flex justify-between items-center shadow-lg z-10 shrink-0">
        <div>
            <div class="flex items-center gap-2">
                <span class="bg-blue-600 text-xs font-bold px-2 py-1 rounded">B3</span>
                <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-emerald-400">
                    The Gradient Vector
                </h1>
            </div>
            <p class="text-xs text-slate-400 mt-1">Visualizing Steepest Ascent & Descent | <span class="text-slate-500">Click surface to place point ‚Ä¢ Arrow keys to nudge ‚Ä¢ Space to toggle descent</span></p>
        </div>
        
        <div class="flex gap-6 text-xs font-mono">
            <div class="flex flex-col items-end">
                <span class="text-emerald-400">‚àáf = [<span id="val-grad-x">0.00</span>, <span id="val-grad-y">0.00</span>]</span>
                <span class="text-purple-400">|‚àáf| = <span id="val-grad-mag">0.000</span></span>
            </div>
            <div class="flex flex-col items-end">
                <span class="text-slate-400">Position: (<span id="val-pos-x">1.50</span>, <span id="val-pos-y">1.50</span>)</span>
                <span class="text-blue-300">Height f(x,y): <span id="val-pos-z">0.00</span></span>
            </div>
            <div id="grad-status" class="hidden flex items-center text-yellow-400 font-bold">
                ‚ö†Ô∏è Critical Point
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 relative flex overflow-hidden">
        
        <!-- Canvas Container -->
        <div class="relative flex-1 bg-black h-full cursor-crosshair" id="canvas-container">
            <canvas id="renderer-canvas" class="w-full h-full block"></canvas>
            
            <!-- View Labels -->
            <div class="absolute top-4 left-4 bg-black/50 backdrop-blur px-2 py-1 rounded text-xs border border-white/10 pointer-events-none">
                3D Perspective
            </div>
            <div id="label-top-down" class="hidden absolute top-4 right-4 bg-black/50 backdrop-blur px-2 py-1 rounded text-xs border border-white/10 pointer-events-none">
                Top-Down (xy-plane)
            </div>

            <!-- Overlay Legend -->
            <div class="absolute bottom-6 left-6 bg-slate-900/90 backdrop-blur-md p-4 rounded-lg border border-slate-700 shadow-xl max-w-xs pointer-events-none select-none z-10">
                <h3 class="text-sm font-bold mb-2 text-slate-300 border-b border-slate-700 pb-1">Legend</h3>
                <div class="space-y-2 text-xs">
                    <div class="flex items-center gap-2">
                        <div class="w-8 h-0.5 bg-emerald-500 relative">
                            <div class="absolute right-0 top-1/2 -translate-y-1/2 border-l-4 border-l-emerald-500 border-y-4 border-y-transparent"></div>
                        </div>
                        <span>+‚àáf <span class="text-slate-400 ml-1 italic">Steepest Ascent</span></span>
                    </div>
                    <div id="legend-neg-grad" class="flex items-center gap-2">
                        <div class="w-8 h-0.5 bg-rose-500 relative">
                            <div class="absolute right-0 top-1/2 -translate-y-1/2 border-l-4 border-l-rose-500 border-y-4 border-y-transparent"></div>
                        </div>
                        <span>‚àí‚àáf <span class="text-slate-400 ml-1 italic">Steepest Descent</span></span>
                    </div>
                    <div id="legend-xy-plane" class="flex items-center gap-2">
                        <div class="w-6 h-0.5 bg-emerald-300 opacity-50"></div>
                        <span class="text-slate-400">Gradient on xy-plane</span>
                    </div>
                    <div id="legend-partials" class="hidden space-y-2 pt-1 border-t border-slate-700 mt-1">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 bg-blue-500 rounded-sm"></div>
                            <span>‚àÇf/‚àÇx <span class="text-slate-500">(x-component)</span></span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 bg-yellow-500 rounded-sm"></div>
                            <span>‚àÇf/‚àÇy <span class="text-slate-500">(y-component)</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step Formula Popup -->
            <div id="step-formula" class="hidden absolute bottom-6 right-6 bg-slate-900/95 backdrop-blur-md p-4 rounded-lg border border-emerald-700 shadow-xl z-10 font-mono text-sm transition-opacity duration-300">
                <div class="text-slate-400 mb-1">w_new = w_old ‚àí Œ±¬∑‚àáf</div>
                <div id="step-formula-values" class="text-emerald-300"></div>
            </div>
        </div>

        <!-- Sidebar Controls -->
        <aside class="w-80 bg-slate-800 border-l border-slate-700 p-4 overflow-y-auto z-20 shadow-xl flex flex-col gap-5 shrink-0">
            
            <!-- Surface Selection -->
            <section>
                <h2 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-3">Surface Function</h2>
                <div class="grid grid-cols-2 gap-2" id="func-buttons">
                    <button data-id="bowl" class="func-btn bg-blue-600 border-blue-500 text-white p-2 text-xs font-medium rounded border transition-colors">Bowl</button>
                    <button data-id="saddle" class="func-btn bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600 p-2 text-xs font-medium rounded border transition-colors">Saddle</button>
                    <button data-id="wavy" class="func-btn bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600 p-2 text-xs font-medium rounded border transition-colors">Wavy</button>
                    <button data-id="loss" class="func-btn bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600 p-2 text-xs font-medium rounded border transition-colors">üìâ ML Loss</button>
                </div>
                <div class="mt-2 space-y-1">
                    <div id="func-equation" class="p-2 bg-slate-900 rounded font-mono text-xs text-center text-blue-300 border border-slate-700">
                        f(x,y) = 0.25(x¬≤ + y¬≤)
                    </div>
                    <div id="grad-equation" class="p-2 bg-slate-900 rounded font-mono text-xs text-center text-emerald-300 border border-slate-700">
                        ‚àáf = [0.5x, 0.5y]
                    </div>
                </div>
                
                <!-- Hint Box -->
                <div id="hint-box" class="hint-box mt-3 p-3 rounded-lg">
                    <p class="text-xs text-amber-300"><span class="font-bold">üí°</span> <span id="hint-text">The gradient always points away from the minimum at (0,0). Watch it shrink to zero as you approach!</span></p>
                </div>
            </section>

            <!-- Visualization Controls -->
            <section class="space-y-3">
                <h2 class="text-sm font-bold text-slate-400 uppercase tracking-wider">Visualization</h2>
                
                <label class="flex items-center justify-between cursor-pointer group">
                    <span class="text-sm text-slate-300 group-hover:text-white">Negative Gradient</span>
                    <div class="relative">
                        <input type="checkbox" id="check-neg-grad" checked class="sr-only peer">
                        <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-rose-600"></div>
                    </div>
                </label>

                <label class="flex items-center justify-between cursor-pointer group">
                    <span class="text-sm text-slate-300 group-hover:text-white">Partial Components</span>
                    <div class="relative">
                        <input type="checkbox" id="check-partials" class="sr-only peer">
                        <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </div>
                </label>

                <label class="flex items-center justify-between cursor-pointer group">
                    <span class="text-sm text-slate-300 group-hover:text-white">Show xy-Plane Gradient</span>
                    <div class="relative">
                        <input type="checkbox" id="check-xy-grad" checked class="sr-only peer">
                        <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-600"></div>
                    </div>
                </label>

                <button id="btn-split-screen" class="w-full py-2 rounded text-sm font-medium flex items-center justify-center gap-2 transition-colors border border-transparent hover:border-indigo-400 bg-slate-700 text-slate-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="3" x2="12" y2="21"></line></svg>
                    <span id="txt-split-screen">Split View (Top-Down)</span>
                </button>
            </section>

            <!-- Gradient Descent Controls -->
            <section class="space-y-4 border-t border-slate-700 pt-4">
                <h2 class="text-sm font-bold text-slate-400 uppercase tracking-wider">Gradient Descent</h2>
                
                <div class="space-y-1">
                    <div class="flex justify-between text-xs text-slate-400">
                        <span>Learning Rate (Œ±)</span>
                        <span id="val-learning-rate">0.10</span>
                    </div>
                    <input type="range" id="input-learning-rate" min="0.01" max="0.5" step="0.01" value="0.1" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <div class="grid grid-cols-2 gap-2">
                    <button id="btn-step-up" class="flex items-center justify-center gap-2 bg-emerald-700 hover:bg-emerald-600 text-white p-2 rounded text-sm font-medium transition-colors" title="Step in +‚àáf direction (W key)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>
                        Ascend
                    </button>
                    <button id="btn-step-down" class="flex items-center justify-center gap-2 bg-rose-700 hover:bg-rose-600 text-white p-2 rounded text-sm font-medium transition-colors" title="Step in -‚àáf direction (S key)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>
                        Descend
                    </button>
                </div>

                <div class="flex gap-2">
                   <button id="btn-toggle-descent" class="flex-1 py-2 rounded text-white text-sm font-bold flex items-center justify-center gap-2 transition-all shadow-lg active:scale-95 bg-blue-600 hover:bg-blue-500" title="Spacebar to toggle">
                    <span id="icon-play-pause">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    </span>
                    <span id="txt-descent-btn">Auto Descent</span>
                  </button>
                  <button id="btn-reset" class="bg-slate-600 hover:bg-slate-500 text-white p-2 rounded transition-colors" title="Reset Position (R key)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                  </button>
                </div>
                
                <p class="text-xs text-slate-500 text-center">
                    Click anywhere on surface to place point
                </p>
            </section>

            <!-- ML Insight (shown only for loss function) -->
            <section id="ml-insight" class="hidden p-3 bg-indigo-900/30 border border-indigo-700/50 rounded-lg">
                <h3 class="text-sm font-bold text-indigo-300 mb-2">ü§ñ ML Connection</h3>
                <p class="text-xs text-indigo-200">Here x and y represent two weights (w‚ÇÅ, w‚ÇÇ). The gradient tells you how to adjust <em>each weight independently</em> to reduce loss. This is exactly what backpropagation computes for millions of weights!</p>
            </section>
        </aside>
    </div>

    <script>
        // --- State Management ---
        const state = {
            currentFuncId: 'bowl',
            learningRate: 0.1,
            showNegativeGrad: true,
            showPartials: false,
            showXYGrad: true,
            showSplitScreen: false,
            isDescending: false,
            posX: 1.5,
            posY: 1.5,
            posZ: 0
        };

        const functions = {
            bowl: { 
                name: 'Bowl', 
                fn: (x, y) => (x * x + y * y) * 0.25,
                eq: 'f(x,y) = 0.25(x¬≤ + y¬≤)',
                gradEq: '‚àáf = [0.5x, 0.5y]',
                hint: 'The gradient always points away from the minimum at (0,0). Watch it shrink to zero as you approach‚Äîthat\'s how you know you\'ve arrived!'
            },
            saddle: { 
                name: 'Saddle', 
                fn: (x, y) => (x * x - y * y) * 0.25,
                eq: 'f(x,y) = 0.25(x¬≤ ‚àí y¬≤)',
                gradEq: '‚àáf = [0.5x, ‚àí0.5y]',
                hint: 'At the origin, gradient is zero‚Äîbut it\'s a saddle point, not a minimum! Try descending from different starting points. Some paths escape, others get stuck.'
            },
            wavy: { 
                name: 'Wavy', 
                fn: (x, y) => Math.sin(x) + Math.cos(y),
                eq: 'f(x,y) = sin(x) + cos(y)',
                gradEq: '‚àáf = [cos(x), ‚àísin(y)]',
                hint: 'Multiple local minima! Gradient descent finds the nearest valley‚Äînot necessarily the deepest. This is why initialization matters in neural networks.'
            },
            loss: {
                name: 'ML Loss',
                fn: (x, y) => 0.5 * ((x - 1) ** 2 + (y + 0.5) ** 2) + 0.2,
                eq: 'L(w‚ÇÅ,w‚ÇÇ) = ¬Ω[(w‚ÇÅ‚àí1)¬≤ + (w‚ÇÇ+0.5)¬≤]',
                gradEq: '‚àáL = [w‚ÇÅ‚àí1, w‚ÇÇ+0.5]',
                hint: 'This is a loss surface! The minimum is at w‚ÇÅ=1, w‚ÇÇ=‚àí0.5. Watch gradient descent find the optimal weights. The gradient gives the direction; the learning rate controls the step size.'
            }
        };

        // --- Three.js Globals ---
        let scene, camera, topCamera, renderer, controls;
        let surfaceMesh, currentPointMesh, cursorMesh;
        let gradientArrow, negGradientArrow, partialXArrow, partialYArrow;
        let gradientArrowXY, negGradientArrowXY; // Gradient on xy-plane
        let trailLine, contourLines, gridHelper;
        let dropLine, floorMarker, criticalPointMarker;
        let raycaster, mouse;
        let trailPoints = [];
        let isDragging = false;
        let stepFormulaTimeout = null;

        // --- Initialization ---
        function init() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('renderer-canvas');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);

            // Cameras
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
            camera.position.set(6, 6, 6);
            camera.up.set(0, 0, 1);

            const frustumSize = 8;
            topCamera = new THREE.OrthographicCamera(
                -frustumSize / 2, frustumSize / 2,
                frustumSize / 2, -frustumSize / 2,
                1, 100
            );
            topCamera.position.set(0, 0, 15);
            topCamera.up.set(0, 1, 0);
            topCamera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.autoClear = false;

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 5, 10);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-5, -5, 5);
            scene.add(backLight);

            // Grid
            gridHelper = new THREE.GridHelper(10, 20, 0x334155, 0x1e293b);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);

            // Objects
            initObjects();
            createAxisLabels();
            
            // Interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            setupInteraction();

            // Initial state
            updateSurfaceGeometry();
            resetPosition();
            animate();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            setupUIListeners();
        }

        function initObjects() {
            // Surface
            const geometry = new THREE.PlaneGeometry(6, 6, 80, 80);
            const material = new THREE.MeshStandardMaterial({
                side: THREE.DoubleSide,
                vertexColors: true,
                metalness: 0.1,
                roughness: 0.6
            });
            surfaceMesh = new THREE.Mesh(geometry, material);
            scene.add(surfaceMesh);

            // Wireframe overlay
            const wireGeo = new THREE.WireframeGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.08 });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            surfaceMesh.add(wireframe);

            // Current Point (Ball)
            const sphereGeo = new THREE.SphereGeometry(0.12, 32, 32);
            const sphereMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0x666666,
                metalness: 0.3,
                roughness: 0.4
            });
            currentPointMesh = new THREE.Mesh(sphereGeo, sphereMat);
            scene.add(currentPointMesh);

            // Glow ring around point
            const glowGeo = new THREE.RingGeometry(0.15, 0.25, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xfacc15, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const glowRing = new THREE.Mesh(glowGeo, glowMat);
            currentPointMesh.add(glowRing);

            // Floor marker (shows position on xy-plane)
            const floorMarkerGeo = new THREE.RingGeometry(0.08, 0.14, 32);
            const floorMarkerMat = new THREE.MeshBasicMaterial({ 
                color: 0xfacc15, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            floorMarker = new THREE.Mesh(floorMarkerGeo, floorMarkerMat);
            floorMarker.rotation.x = Math.PI / 2;
            scene.add(floorMarker);

            // Drop line (connects floor to surface)
            const dropLineMat = new THREE.LineDashedMaterial({ 
                color: 0xfacc15, 
                dashSize: 0.1, 
                gapSize: 0.05,
                transparent: true,
                opacity: 0.6
            });
            dropLine = new THREE.Line(new THREE.BufferGeometry(), dropLineMat);
            scene.add(dropLine);

            // Critical point marker
            const critGeo = new THREE.RingGeometry(0.2, 0.35, 32);
            const critMat = new THREE.MeshBasicMaterial({ 
                color: 0xfbbf24, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            criticalPointMarker = new THREE.Mesh(critGeo, critMat);
            criticalPointMarker.visible = false;
            scene.add(criticalPointMarker);

            // Cursor Plane (invisible, for raycasting)
            cursorMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100), 
                new THREE.MeshBasicMaterial({ visible: false })
            );
            scene.add(cursorMesh);

            // --- Arrows on Surface ---
            // Gradient (Green)
            gradientArrow = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0), 
                new THREE.Vector3(0, 0, 0), 
                1, 0x10b981, 0.2, 0.12
            );
            scene.add(gradientArrow);

            // Negative Gradient (Rose)
            negGradientArrow = new THREE.ArrowHelper(
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 0),
                1, 0xe11d48, 0.2, 0.12
            );
            scene.add(negGradientArrow);

            // --- Arrows on XY-Plane (z=0) ---
            gradientArrowXY = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0), 
                new THREE.Vector3(0, 0, 0), 
                1, 0x6ee7b7, 0.15, 0.08  // Lighter green
            );
            gradientArrowXY.children.forEach(child => {
                if (child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            scene.add(gradientArrowXY);

            negGradientArrowXY = new THREE.ArrowHelper(
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 0),
                1, 0xfda4af, 0.15, 0.08  // Lighter rose
            );
            negGradientArrowXY.children.forEach(child => {
                if (child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            scene.add(negGradientArrowXY);

            // Partial Components
            partialXArrow = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0), 
                new THREE.Vector3(0, 0, 0), 
                0.5, 0x3b82f6, 0.12, 0.08
            );
            partialXArrow.visible = false;
            scene.add(partialXArrow);

            partialYArrow = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0), 
                new THREE.Vector3(0, 0, 0), 
                0.5, 0xeab308, 0.12, 0.08
            );
            partialYArrow.visible = false;
            scene.add(partialYArrow);

            // Trail Line
            const trailMat = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6 
            });
            trailLine = new THREE.Line(new THREE.BufferGeometry(), trailMat);
            scene.add(trailLine);

            // Contours Group
            contourLines = new THREE.Group();
            contourLines.position.z = 0.02;
            scene.add(contourLines);
        }

        function createAxisLabels() {
            function makeLabel(text, position, color) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                ctx.fillStyle = color;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 64, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.scale.set(0.8, 0.4, 1);
                scene.add(sprite);
            }
            
            makeLabel('x', new THREE.Vector3(3.5, 0, 0), '#f87171');
            makeLabel('y', new THREE.Vector3(0, 3.5, 0), '#60a5fa');
            makeLabel('f(x,y)', new THREE.Vector3(0.3, 0.3, 2.8), '#94a3b8');
        }

        // --- Surface & Contours ---

        function updateSurfaceGeometry() {
            const fn = functions[state.currentFuncId].fn;
            const geo = surfaceMesh.geometry;
            const pos = geo.attributes.position;
            const colors = [];
            const minH = -2, maxH = 2.5;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z = fn(x, y);
                pos.setZ(i, z);

                const t = THREE.MathUtils.clamp((z - minH) / (maxH - minH), 0, 1);
                const color = new THREE.Color().setHSL(0.65 - (t * 0.65), 0.85, 0.5);
                colors.push(color.r, color.g, color.b);
            }
            
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            pos.needsUpdate = true;
            geo.computeVertexNormals();

            generateContours(fn);
        }

        function generateContours(fn) {
            // Clear old contours
            while(contourLines.children.length) {
                const child = contourLines.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                contourLines.remove(child);
            }

            // Generate contour levels
            const levels = [-1, -0.5, 0, 0.5, 1, 1.5, 2];
            const resolution = 80;
            const range = 3;

            levels.forEach(level => {
                const points = [];
                
                // Sample around angles to find level set
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.03) {
                    // Binary search for radius where fn(x,y) ‚âà level
                    let rMin = 0, rMax = range;
                    for (let iter = 0; iter < 15; iter++) {
                        const rMid = (rMin + rMax) / 2;
                        const x = rMid * Math.cos(angle);
                        const y = rMid * Math.sin(angle);
                        const val = fn(x, y);
                        
                        if (val < level) {
                            rMin = rMid;
                        } else {
                            rMax = rMid;
                        }
                    }
                    
                    const r = (rMin + rMax) / 2;
                    if (r > 0.1 && r < range - 0.1) {
                        const x = r * Math.cos(angle);
                        const y = r * Math.sin(angle);
                        if (Math.abs(fn(x, y) - level) < 0.1) {
                            points.push(new THREE.Vector3(x, y, 0.03));
                        }
                    }
                }
                
                if (points.length > 5) {
                    points.push(points[0].clone()); // Close loop
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const t = THREE.MathUtils.clamp((level + 1) / 3, 0, 1);
                    const color = new THREE.Color().setHSL(0.65 - t * 0.65, 0.7, 0.55);
                    const mat = new THREE.LineBasicMaterial({ 
                        color, 
                        transparent: true, 
                        opacity: 0.5 
                    });
                    contourLines.add(new THREE.Line(geo, mat));
                }
            });
        }

        // --- Gradient Calculations ---

        function getGradient(x, y) {
            const h = 0.001;
            const fn = functions[state.currentFuncId].fn;
            const dx = (fn(x + h, y) - fn(x - h, y)) / (2 * h);
            const dy = (fn(x, y + h) - fn(x, y - h)) / (2 * h);
            return { x: dx, y: dy };
        }

        function updateGradientVisuals() {
            const x = state.posX;
            const y = state.posY;
            const z = functions[state.currentFuncId].fn(x, y);
            state.posZ = z;

            // Position ball on surface
            currentPointMesh.position.set(x, y, z);
            
            // Floor marker
            floorMarker.position.set(x, y, 0.01);
            
            // Drop line
            dropLine.geometry.dispose();
            dropLine.geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(x, y, 0.01),
                new THREE.Vector3(x, y, z - 0.1)
            ]);
            dropLine.computeLineDistances();

            // Calculate gradient
            const grad = getGradient(x, y);
            const magnitude = Math.sqrt(grad.x * grad.x + grad.y * grad.y);
            
            // Update UI stats
            document.getElementById('val-grad-x').textContent = grad.x.toFixed(2);
            document.getElementById('val-grad-y').textContent = grad.y.toFixed(2);
            document.getElementById('val-grad-mag').textContent = magnitude.toFixed(3);
            document.getElementById('val-pos-x').textContent = x.toFixed(2);
            document.getElementById('val-pos-y').textContent = y.toFixed(2);
            document.getElementById('val-pos-z').textContent = z.toFixed(2);

            // Arrow positioning
            const surfaceOrigin = new THREE.Vector3(x, y, z + 0.15);
            const floorOrigin = new THREE.Vector3(x, y, 0.08);
            
            // Check for critical point (near-zero gradient)
            const isCritical = magnitude < 0.08;
            document.getElementById('grad-status').classList.toggle('hidden', !isCritical);
            criticalPointMarker.visible = isCritical;
            
            if (isCritical) {
                criticalPointMarker.position.set(x, y, z + 0.2);
                criticalPointMarker.lookAt(camera.position);
            }

            if (magnitude > 0.01) {
                const dir = new THREE.Vector3(grad.x, grad.y, 0).normalize();
                
                // Logarithmic scaling for visual length
                const visualLength = Math.log(1 + magnitude * 3) * 0.8;
                
                // --- Surface arrows ---
                gradientArrow.visible = true;
                gradientArrow.position.copy(surfaceOrigin);
                gradientArrow.setDirection(dir);
                gradientArrow.setLength(visualLength, 0.18, 0.1);

                if (state.showNegativeGrad) {
                    negGradientArrow.visible = true;
                    negGradientArrow.position.copy(surfaceOrigin);
                    negGradientArrow.setDirection(dir.clone().negate());
                    negGradientArrow.setLength(visualLength, 0.18, 0.1);
                } else {
                    negGradientArrow.visible = false;
                }

                // --- XY-plane arrows ---
                if (state.showXYGrad) {
                    gradientArrowXY.visible = true;
                    gradientArrowXY.position.copy(floorOrigin);
                    gradientArrowXY.setDirection(dir);
                    gradientArrowXY.setLength(visualLength, 0.12, 0.07);

                    if (state.showNegativeGrad) {
                        negGradientArrowXY.visible = true;
                        negGradientArrowXY.position.copy(floorOrigin);
                        negGradientArrowXY.setDirection(dir.clone().negate());
                        negGradientArrowXY.setLength(visualLength, 0.12, 0.07);
                    } else {
                        negGradientArrowXY.visible = false;
                    }
                } else {
                    gradientArrowXY.visible = false;
                    negGradientArrowXY.visible = false;
                }

                // --- Partial component arrows ---
                if (state.showPartials) {
                    const xLen = Math.log(1 + Math.abs(grad.x) * 3) * 0.6;
                    const yLen = Math.log(1 + Math.abs(grad.y) * 3) * 0.6;
                    
                    partialXArrow.visible = true;
                    partialXArrow.position.copy(surfaceOrigin);
                    partialXArrow.setDirection(new THREE.Vector3(Math.sign(grad.x) || 1, 0, 0));
                    partialXArrow.setLength(Math.max(xLen, 0.1), 0.1, 0.06);

                    partialYArrow.visible = true;
                    partialYArrow.position.copy(surfaceOrigin);
                    partialYArrow.setDirection(new THREE.Vector3(0, Math.sign(grad.y) || 1, 0));
                    partialYArrow.setLength(Math.max(yLen, 0.1), 0.1, 0.06);
                } else {
                    partialXArrow.visible = false;
                    partialYArrow.visible = false;
                }

            } else {
                // Hide arrows at critical point
                gradientArrow.visible = false;
                negGradientArrow.visible = false;
                gradientArrowXY.visible = false;
                negGradientArrowXY.visible = false;
                partialXArrow.visible = false;
                partialYArrow.visible = false;
            }
        }

        // --- Gradient Descent ---

        function step(uphill) {
            const grad = getGradient(state.posX, state.posY);
            const direction = uphill ? 1 : -1;
            const lr = state.learningRate;
            
            const newX = state.posX + (grad.x * lr * direction);
            const newY = state.posY + (grad.y * lr * direction);

            // Show formula popup
            showStepFormula(state.posX, state.posY, newX, newY, grad, lr, uphill);

            // Bounds check
            if (newX < -2.9 || newX > 2.9 || newY < -2.9 || newY > 2.9) {
                return;
            }

            state.posX = newX;
            state.posY = newY;

            addToTrail(newX, newY, functions[state.currentFuncId].fn(newX, newY));
            updateGradientVisuals();
        }

        function showStepFormula(oldX, oldY, newX, newY, grad, lr, uphill) {
            const formulaEl = document.getElementById('step-formula');
            const valuesEl = document.getElementById('step-formula-values');
            
            const sign = uphill ? '+' : '‚àí';
            valuesEl.innerHTML = `[${newX.toFixed(2)}, ${newY.toFixed(2)}] = [${oldX.toFixed(2)}, ${oldY.toFixed(2)}] ${sign} ${lr.toFixed(2)}¬∑[${grad.x.toFixed(2)}, ${grad.y.toFixed(2)}]`;
            
            formulaEl.classList.remove('hidden');
            
            // Clear existing timeout
            if (stepFormulaTimeout) clearTimeout(stepFormulaTimeout);
            
            // Hide after delay (longer if auto-descending)
            stepFormulaTimeout = setTimeout(() => {
                formulaEl.classList.add('hidden');
            }, state.isDescending ? 800 : 2500);
        }

        function addToTrail(x, y, z) {
            trailPoints.push(new THREE.Vector3(x, y, z + 0.05));
            if (trailPoints.length > 150) trailPoints.shift();
            
            trailLine.geometry.dispose();
            trailLine.geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
        }

        function resetPosition() {
            state.isDescending = false;
            updatePlayButton();
            
            // Start position depends on function
            if (state.currentFuncId === 'loss') {
                state.posX = -1.5;
                state.posY = 1.5;
            } else {
                state.posX = 1.5;
                state.posY = 1.5;
            }
            
            trailPoints = [];
            trailLine.geometry.dispose();
            trailLine.geometry = new THREE.BufferGeometry();
            
            document.getElementById('step-formula').classList.add('hidden');
            
            updateGradientVisuals();
        }

        // --- Interaction ---

        function setupInteraction() {
            const canvas = document.getElementById('renderer-canvas');
            
            canvas.addEventListener('mousedown', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);
                
                // Click anywhere on surface to teleport
                const intersects = raycaster.intersectObject(surfaceMesh);
                
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    state.posX = THREE.MathUtils.clamp(pt.x, -2.9, 2.9);
                    state.posY = THREE.MathUtils.clamp(pt.y, -2.9, 2.9);
                    
                    // Clear trail on teleport
                    trailPoints = [];
                    trailLine.geometry.dispose();
                    trailLine.geometry = new THREE.BufferGeometry();
                    
                    isDragging = true;
                    controls.enabled = false;
                    updateGradientVisuals();
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(cursorMesh);
                
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    state.posX = THREE.MathUtils.clamp(pt.x, -2.9, 2.9);
                    state.posY = THREE.MathUtils.clamp(pt.y, -2.9, 2.9);
                    updateGradientVisuals();
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                controls.enabled = true;
            });
        }

        function updateMouse(e) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            // Handle split screen - only use left half for perspective camera interaction
            const effectiveWidth = state.showSplitScreen ? rect.width / 2 : rect.width;
            
            mouse.x = ((e.clientX - rect.left) / effectiveWidth) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onKeyDown(e) {
            // Don't capture if typing in an input
            if (e.target.tagName === 'INPUT') return;
            
            const nudge = e.shiftKey ? 0.3 : 0.1;
            let handled = false;
            
            switch(e.key.toLowerCase()) {
                case 'arrowleft':
                    state.posX = Math.max(-2.9, state.posX - nudge);
                    handled = true;
                    break;
                case 'arrowright':
                    state.posX = Math.min(2.9, state.posX + nudge);
                    handled = true;
                    break;
                case 'arrowup':
                    state.posY = Math.min(2.9, state.posY + nudge);
                    handled = true;
                    break;
                case 'arrowdown':
                    state.posY = Math.max(-2.9, state.posY - nudge);
                    handled = true;
                    break;
                case ' ':
                    state.isDescending = !state.isDescending;
                    updatePlayButton();
                    handled = true;
                    break;
                case 's':
                    step(false);
                    handled = true;
                    break;
                case 'w':
                    step(true);
                    handled = true;
                    break;
                case 'r':
                    resetPosition();
                    handled = true;
                    break;
            }
            
            if (handled) {
                e.preventDefault();
                // Clear trail on manual movement
                if (['arrowleft', 'arrowright', 'arrowup', 'arrowdown'].includes(e.key.toLowerCase())) {
                    trailPoints = [];
                    trailLine.geometry.dispose();
                    trailLine.geometry = new THREE.BufferGeometry();
                }
                updateGradientVisuals();
            }
        }

        // --- UI Listeners ---

        function setupUIListeners() {
            // Function Buttons
            document.querySelectorAll('.func-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = e.target.getAttribute('data-id');
                    state.currentFuncId = id;
                    
                    // Update button styles
                    document.querySelectorAll('.func-btn').forEach(b => {
                        b.className = 'func-btn bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600 p-2 text-xs font-medium rounded border transition-colors';
                    });
                    e.target.className = 'func-btn bg-blue-600 border-blue-500 text-white p-2 text-xs font-medium rounded border transition-colors';
                    
                    // Update formulas and hint
                    const func = functions[id];
                    document.getElementById('func-equation').textContent = func.eq;
                    document.getElementById('grad-equation').textContent = func.gradEq;
                    document.getElementById('hint-text').textContent = func.hint;
                    
                    // Show/hide ML insight
                    document.getElementById('ml-insight').classList.toggle('hidden', id !== 'loss');
                    
                    updateSurfaceGeometry();
                    resetPosition();
                });
            });

            // Toggles
            document.getElementById('check-neg-grad').addEventListener('change', (e) => {
                state.showNegativeGrad = e.target.checked;
                document.getElementById('legend-neg-grad').style.display = e.target.checked ? 'flex' : 'none';
                updateGradientVisuals();
            });

            document.getElementById('check-partials').addEventListener('change', (e) => {
                state.showPartials = e.target.checked;
                document.getElementById('legend-partials').classList.toggle('hidden', !e.target.checked);
                updateGradientVisuals();
            });

            document.getElementById('check-xy-grad').addEventListener('change', (e) => {
                state.showXYGrad = e.target.checked;
                document.getElementById('legend-xy-plane').style.display = e.target.checked ? 'flex' : 'none';
                updateGradientVisuals();
            });

            // Split Screen
            document.getElementById('btn-split-screen').addEventListener('click', () => {
                state.showSplitScreen = !state.showSplitScreen;
                
                const btn = document.getElementById('btn-split-screen');
                if (state.showSplitScreen) {
                    btn.classList.remove('bg-slate-700', 'text-slate-300');
                    btn.classList.add('bg-indigo-600', 'text-white');
                    document.getElementById('txt-split-screen').textContent = 'Single View';
                    document.getElementById('label-top-down').classList.remove('hidden');
                } else {
                    btn.classList.remove('bg-indigo-600', 'text-white');
                    btn.classList.add('bg-slate-700', 'text-slate-300');
                    document.getElementById('txt-split-screen').textContent = 'Split View (Top-Down)';
                    document.getElementById('label-top-down').classList.add('hidden');
                }
                
                onWindowResize();
            });

            // Descent controls
            document.getElementById('input-learning-rate').addEventListener('input', (e) => {
                state.learningRate = parseFloat(e.target.value);
                document.getElementById('val-learning-rate').textContent = state.learningRate.toFixed(2);
            });

            document.getElementById('btn-step-up').addEventListener('click', () => step(true));
            document.getElementById('btn-step-down').addEventListener('click', () => step(false));

            document.getElementById('btn-toggle-descent').addEventListener('click', () => {
                state.isDescending = !state.isDescending;
                updatePlayButton();
            });

            document.getElementById('btn-reset').addEventListener('click', resetPosition);
        }

        function updatePlayButton() {
            const btn = document.getElementById('btn-toggle-descent');
            const iconSpan = document.getElementById('icon-play-pause');
            const txt = document.getElementById('txt-descent-btn');
            
            const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
            const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;

            if (state.isDescending) {
                btn.classList.remove('bg-blue-600', 'hover:bg-blue-500');
                btn.classList.add('bg-yellow-600', 'hover:bg-yellow-500');
                iconSpan.innerHTML = pauseIcon;
                txt.textContent = 'Pause Descent';
            } else {
                btn.classList.remove('bg-yellow-600', 'hover:bg-yellow-500');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-500');
                iconSpan.innerHTML = playIcon;
                txt.textContent = 'Auto Descent';
            }
        }

        // --- Animation & Rendering ---

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            renderer.setSize(width, height);
            
            if (state.showSplitScreen) {
                camera.aspect = (width / 2) / height;
            } else {
                camera.aspect = width / height;
            }
            camera.updateProjectionMatrix();
        }

        let glowPhase = 0;
        let criticalPhase = 0;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Animate glow ring
            glowPhase += 0.05;
            if (currentPointMesh.children[0]) {
                currentPointMesh.children[0].material.opacity = 0.3 + 0.2 * Math.sin(glowPhase);
            }

            // Animate critical point marker
            if (criticalPointMarker.visible) {
                criticalPhase += 0.08;
                criticalPointMarker.material.opacity = 0.5 + 0.3 * Math.sin(criticalPhase);
                criticalPointMarker.scale.setScalar(1 + 0.1 * Math.sin(criticalPhase * 0.5));
            }

            // Auto descent
            if (state.isDescending && !isDragging) {
                step(false);
            }

            render();
        }

        function render() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            renderer.setScissorTest(false);
            renderer.clear();

            if (state.showSplitScreen) {
                // Left: Perspective view
                renderer.setScissorTest(true);
                renderer.setScissor(0, 0, width / 2, height);
                renderer.setViewport(0, 0, width / 2, height);
                camera.aspect = (width / 2) / height;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);

                // Right: Top-down view
                renderer.setScissor(width / 2, 0, width / 2, height);
                renderer.setViewport(width / 2, 0, width / 2, height);
                
                const aspect = (width / 2) / height;
                const frustumSize = 8;
                topCamera.left = -frustumSize * aspect / 2;
                topCamera.right = frustumSize * aspect / 2;
                topCamera.top = frustumSize / 2;
                topCamera.bottom = -frustumSize / 2;
                topCamera.updateProjectionMatrix();
                
                renderer.render(scene, topCamera);
            } else {
                renderer.setViewport(0, 0, width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
            }
        }

        // Initialize
        init();
    </script>
</body>
</html>
